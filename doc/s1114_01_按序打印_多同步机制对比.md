# Print in Order（多同步机制对比）

## 题解

---

### 问题描述

假设有一个类：

```java
public class Foo {
    public void first() { print("first"); }
    public void second() { print("second"); }
    public void third() { print("third"); }
}
```

同一个 Foo 实例将被传递给三个不同的线程。线程 A 将调用 first()，线程 B 将调用 second()，线程 C 将调用 third()。设计一个机制并修改程序，确保 second() 在 first() 之后执行，third() 在 second() 之后执行。

**注意**：我们不知道操作系统将如何调度线程，即使输入中的数字似乎暗示了顺序。你看到的输入格式主要是为了确保我们测试的全面性。

**示例 1**：

```text
输入：nums = [1,2,3]
输出："firstsecondthird"
解释：有三个线程被异步触发。输入 [1,2,3] 表示线程 A 调用 first()，线程 B 调用 second()，线程 C 调用 third()。"firstsecondthird" 是正确的输出。
```

**示例 2**：

```text
输入：nums = [1,3,2]
输出："firstsecondthird"
解释：输入 [1,3,2] 表示线程 A 调用 first()，线程 B 调用 third()，线程 C 调用 second()。"firstsecondthird" 是正确的输出。
```

**约束条件**：

* nums 是 [1, 2, 3] 的一个排列

---

### 抽象设计

#### 顺序打印 Trait

```rust
pub trait PrintInOrderTrait {
    fn new() -> Self where Self: Sized;
    fn first<F>(&self, print_first: F) where F: FnOnce();
    fn second<F>(&self, print_second: F) where F: FnOnce();
    fn third<F>(&self, print_third: F) where F: FnOnce();
}
```

**设计思想**：

* **统一接口**：为不同的同步机制提供一致的调用方式
* **泛型约束**：确保具体类型的可实例化
* **函数参数**：使用 `FnOnce` 闭包支持灵活的打印操作

---

### 实现方案对比

#### 1. 条件变量实现（CondVarFoo）

```rust
use std::sync::{Condvar, Mutex};

pub struct CondVarFoo {
    state: Mutex<i32>,
    cv: Condvar,
}
```

**核心思想**：

* 使用互斥锁保护共享状态
* 使用条件变量进行线程等待和通知
* 状态机：0 → 1 → 2 表示执行进度

**同步机制**：

* `first`：等待状态为0，执行后设为1，通知所有等待线程
* `second`：等待状态为1，执行后设为2，通知所有等待线程  
* `third`：等待状态为2，执行后结束

**优点**：

* 传统同步方式，成熟稳定
* 适合复杂同步场景
* 支持多个等待线程

**缺点**：

* 锁竞争可能影响性能
* 实现相对复杂

#### 2. 通道实现（ChannelFoo）

```rust
use std::sync::mpsc::{channel, Sender, Receiver};

pub struct ChannelFoo {
    tx1: Sender<()>,
    rx1: Receiver<()>,
    tx2: Sender<()>,
    rx2: Receiver<()>,
}
```

**核心思想**：

* 使用消息传递进行线程同步
* 两个通道分别控制 first→second 和 second→third 的同步
* 发送空消息作为同步信号

**同步机制**：

* `first`：执行后发送信号给 second
* `second`：等待 first 的信号，执行后发送信号给 third
* `third`：等待 second 的信号，执行后结束

**优点**：

* 逻辑清晰，易于理解
* 无锁设计，避免竞争
* 适合简单同步场景

**缺点**：

* 通道创建和销毁有开销
* 不适合大量线程同步

#### 3. 原子变量实现（AtomicFoo）

```rust
use std::sync::atomic::{AtomicI32, Ordering};

pub struct AtomicFoo {
    state: AtomicI32,
}
```

**核心思想**：

* 使用原子操作进行无锁同步
* 忙等待（busy-wait）模式，使用 `yield_now()` 减少 CPU 占用
* 原子状态保证内存可见性

**同步机制**：

* `first`：忙等待状态为0，执行后设为1
* `second`：忙等待状态为1，执行后设为2
* `third`：忙等待状态为2，执行后结束

**优点**：

* 无锁设计，性能高
* 实现简单
* 适合低延迟场景

**缺点**：

* 忙等待消耗 CPU 资源
* 不适合高并发场景

### 性能对比分析

#### 时间复杂度比较

| 实现方案 | first | second | third | 总体复杂度 |
|---------|-------|--------|-------|-----------|
| 条件变量 | O(1) | O(1) | O(1) | O(1) |
| 通道 | O(1) | O(1) | O(1) | O(1) |
| 原子变量 | O(1) | O(1) | O(1) | O(1) |

*注：所有操作的时间复杂度都是 O(1)，但实际性能受同步机制影响*

#### 空间复杂度比较

| 实现方案 | 额外空间 | 空间效率 |
| --------- | --------- | --------- |
| 条件变量 | O(1) | 高 |
| 通道 | O(1) | 高 |
| 原子变量 | O(1) | 高 |

#### 适用场景推荐

1. **通用场景**：推荐条件变量实现（成熟稳定）
2. **简单同步**：推荐通道实现（逻辑清晰）
3. **性能敏感**：推荐原子变量实现（低延迟）

---

### 测试用例设计

#### 基础功能测试

```rust
fn test_basic_operations<T: PrintInOrderTrait>() {
    let foo = T::new();
    let mut output = String::new();
    foo.first(|| output.push_str("first"));
    foo.second(|| output.push_str("second"));
    foo.third(|| output.push_str("third"));
    assert_eq!(output, "firstsecondthird");
}
```

**测试重点**：

验证顺序执行的正确性
测试单线程场景
确保基本功能正常

#### 并发功能测试

```rust
fn test_concurrent_operations<T: PrintInOrderTrait + Send + Sync + 'static>() {
    let foo = Arc::new(T::new());
    let output = Arc::new(Mutex::new(String::new()));
    
    // 创建三个线程乱序执行
    let f1 = thread::spawn(|| { /* first */ });
    let f2 = thread::spawn(|| { /* second */ });
    let f3 = thread::spawn(|| { /* third */ });
    
    // 等待所有线程完成
    f1.join().unwrap();
    f2.join().unwrap();
    f3.join().unwrap();
    
    assert_eq!(&*output.lock().unwrap(), "firstsecondthird");
}
```

**测试重点**：

验证线程同步的正确性
测试乱序启动的场景
确保并发安全性

#### 性能测试

```rust
fn performance_test<T: PrintInOrderTrait + Send + Sync + 'static>(impl_name: &str) {
    let start = std::time::Instant::now();
    
    // 测试多次并发执行
    for _ in 0..100 {
        // 创建线程并执行
    }
    
    let duration = start.elapsed();
    println!("{} 性能测试完成: {:?}", impl_name, duration);
}
```

**测试重点**：

比较不同实现的性能
测试高并发场景
评估资源消耗

#### 压力测试

```rust
fn stress_test<T: PrintInOrderTrait + Send + Sync + 'static>(impl_name: &str) {
    // 创建大量线程组进行测试
    for group in 0..10 {
        // 每个组创建三个线程
    }
}
```

**测试重点**：
验证实现的稳定性
测试边界情况
评估内存使用

---

### 扩展思考

#### 1. 相关 LeetCode 问题

* **1115. Print FooBar Alternately**：交替打印 FooBar
* **1116. Print Zero Even Odd**：打印零偶奇数
* **1195. Fizz Buzz Multithreaded**：多线程 FizzBuzz

#### 2. 实际应用场景

* **任务流水线**：多阶段任务的有序执行
* **数据预处理**：依赖关系的多线程处理
* **游戏引擎**：渲染管线的阶段同步

#### 3. 同步机制对比总结

| 机制 | 适用场景 | 优点 | 缺点 |
| ------ | ---------- | ------ | ------ |
| 条件变量 | 复杂同步 | 功能强大，成熟稳定 | 锁竞争，实现复杂 |
| 通道 | 简单同步 | 逻辑清晰，无锁设计 | 创建开销，不够灵活 |
| 原子变量 | 性能敏感 | 无锁，低延迟 | 忙等待，CPU 消耗 |
| 屏障 | 固定线程 | 直观简单，无忙等待 | 不够灵活，创建开销 |

#### 4. Rust 同步原语最佳实践

1. **选择合适机制**：根据场景选择最合适的同步原语
2. **避免死锁**：注意锁的获取顺序和生命周期
3. **性能优化**：减少锁竞争，使用无锁数据结构
4. **错误处理**：妥善处理线程 panic 和资源清理

---

### 总结

**核心设计模式**：

1. **状态机同步**：通过状态转移控制执行顺序
2. **消息传递**：使用通道进行线程间通信
3. **原子操作**：无锁同步保证性能

=== 实现方案对比总结 ===

1. 条件变量实现: 传统同步方式，适合复杂同步场景，多线程并发存在锁竞争问题（锁竞争导致频繁睡眠和唤醒，速度下降）
2. 通道实现: 消息传递模式，逻辑清晰，适合简单同步（逻辑简单，无锁竞争，但是有一定开销）
3. 原子变量实现: 无锁同步，性能高，但需要忙等待, 不适合高并发场景(可以引入退避算法，速度最快，综合使用：使用core::hint::spin_loop();但是会占用 CPU 资源，单线程会导致死锁，使用yield 让出 CPU 时间片又会导致上下文切换，速度下降)

### 测试结果

=== 条件变量实现 性能测试 ===
100次并发执行耗时: 15.423578ms

=== 通道实现 性能测试 ===
100次并发执行耗时: 15.516343ms

=== 原子变量实现 性能测试 ===
100次并发执行耗时: 11.672614ms

=== 条件变量实现 压力测试 ===
30个线程并发执行耗时: 1.397721396s
Actual: first0second0third0first2second1third1first3second4third3first4second3third4first6second6third6first7second7third7first9second8third9first8second2third2first1second5third5first5second9third8

=== 通道实现 压力测试 ===
30个线程并发执行耗时: 185.364229ms
Actual: first8first2first1first6second1first4second3first9second0first5first3first0first7second8second4third0second9second6second5second2third1second7third2third3third4third7third9third8third5third6

=== 原子变量实现 压力测试 ===
30个线程并发执行耗时: 154.064783ms
Actual: first8first4first0first1first9first7second0second5second7first3third2third5first2second2third1third0second1third7first5second9second4second6second8second3first6third4third6third9third8third3
