# Reverse Linked List（反转链表）

## 题解

---

### 问题描述

给定单链表的头节点 `head`，请反转链表，并返回反转后的链表。

**示例 1**：

```text
输入：head = [1,2,3,4,5]
输出：[5,4,3,2,1]
```

**示例 2**：

```text
输入：head = [1,2]
输出：[2,1]
```

**示例 3**：

```text
输入：head = []
输出：[]
```

**约束条件**：

- 链表中节点的数目范围是 [0, 5000]
- -5000 <= Node.val <= 5000

**进阶**：链表可以选用迭代或递归方式反转。你能否用两种方法都解决这个问题？

---

### 核心思路

反转链表的核心思想是**改变节点间的指针方向**。通过维护前驱节点(pre)、当前节点(cur)和临时节点(temp)三个指针，逐步将每个节点的next指针指向前一个节点。

#### 反转过程可视化

```text
原链表：1 -> 2 -> 3 -> 4 -> 5 -> None 
迭代过程：
 pre = None, cur = 1 -> 2 -> 3 -> 4 -> 5
 pre = 1 -> None, cur = 2 -> 3 -> 4 -> 5
 pre = 2 -> 1 -> None, cur = 3 -> 4 -> 5
 pre = 3 -> 2 -> 1 -> None, cur = 4 -> 5
 pre = 4 -> 3 -> 2 -> 1 -> None, cur = 5
 pre = 5 -> 4 -> 3 -> 2 -> 1 -> None, cur = None
```

---

### 算法实现

#### 1. 迭代法（Iterative）

```rust
pub fn reverse_list(mut cur: Option<Box<ListNode>>) -> Option<Box<ListNode>> {
    let mut pre = None;
    while let Some(mut node) = cur {
        let temp = node.next.take();
        node.next = pre;
        pre = Some(node);
        cur = temp;
    }
    pre
}
```

**算法步骤**：

1. **初始化**：`pre = None`，`cur = head`
2. **循环条件**：当 `cur` 不为 `None` 时继续
3. **保存临时指针**：`temp = cur.next`
4. **反转指针**：`cur.next = pre`
5. **移动指针**：`pre = cur`，`cur = temp`
6. **返回结果**：循环结束后返回 `pre`

**关键操作解析**：

- `node.next.take()`：安全转移 `next` 指针的所有权
- `node.next = pre`：将当前节点的 `next` 指向前驱节点
- `pre = Some(node)`：更新前驱节点为当前节点

#### 2. 递归法（Recursive）

```rust
pub fn reverse_list2(cur: Option<Box<ListNode>>) -> Option<Box<ListNode>> {
    fn reverse(
        cur: Option<Box<ListNode>>,
        pre: Option<Box<ListNode>>,
    ) -> Option<Box<ListNode>> {
        match cur {
            None => pre,
            Some(mut node) => {
                let temp = node.next.take();
                node.next = pre;
                reverse(temp, Some(node))
            }
        }
    }
    reverse(cur, None)
}
```

**递归过程分析**：

1. **基本情况**：当 `cur` 为 `None` 时，返回 `pre`（反转完成）

2. **递归步骤**：
   - 保存当前节点的下一个节点：`temp = cur.next`
   - 反转指针：`cur.next = pre`
   - 递归调用：`reverse(temp, cur)`

**递归调用栈示例**（链表：1->2->3->None）

reverse(1->2->3, None)
reverse(2->3, 1->None)
reverse(3->None, 2->1->None)
reverse(None, 3->2->1->None)

---

### 复杂度分析

| 方法 | 时间复杂度 | 空间复杂度 | 适用场景 |
| ------ | -------- | -------- | ---------- |
| 迭代法 | O(n) | O(1) | 内存敏感场景，长链表 |
| 递归法 | O(n) | O(n) | 代码简洁，短链表 |

**详细分析**：

- **时间复杂度**：两种方法都需要遍历整个链表，时间复杂度均为O(n)
- **空间复杂度**：
  - 迭代法：只使用常数个指针变量，空间复杂度 O(1)
  - 递归法：需要递归调用栈，深度为链表长度，空间复杂度 O(n)

---

### Rust 实现特色

#### 1. 所有权管理

```rust
let temp = node.next.take();  // 转移所有权
node.next = pre;              // 安全赋值
pre = Some(node);             // 更新前驱
```

**设计要点**：

- `take()` 方法：安全转移 `Option` 内容的所有权
- 避免悬垂指针：Rust 的所有权系统确保内存安全
- 编译时检查：防止空指针异常和数据竞争

#### 2. 模式匹配

```rust
match cur {
    None => pre,              // 基本情况
    Some(mut node) => {       // 递归情况
        // 反转操作
    }
}
```

**优势**：

- 代码清晰：明确处理空链表和有效节点两种情况
- 安全性：编译时检查所有可能的情况
- 表达力：简洁表达递归逻辑

#### 3. 函数式编程风格

```rust
fn reverse(cur: Option<Box<ListNode>>, pre: Option<Box<ListNode>>) 
    -> Option<Box<ListNode>> {
    // 尾递归优化
}
```

**特点**：

- 尾递归：编译器可能进行尾递归优化
- 不可变性：函数参数不可变，避免副作用
- 组合性：易于理解和测试

---

### 算法对比

| 特性 | 迭代法 | 递归法 |
| ------ | -------- | -------- |
| 空间复杂度 | O(1) | O(n) |
| 代码简洁性 | 中等 | 高 |
| 可读性 | 直观 | 抽象 |
| 栈溢出风险 | 无 | 链表过长时可能 |
| 调试难度 | 容易 | 较难 |
| 性能 | 稳定 | 依赖编译器优化 |

**选择建议**：

- **优先迭代法**：处理长链表，内存敏感场景
- **考虑递归法**：代码简洁性优先，链表长度可控时

---

### 测试用例设计

#### 基础功能测试

```rust
#[test]
fn test_206() {
    assert_eq!(
        Solution::reverse_list(linked![1, 2, 3, 4, 5]),
        linked![5, 4, 3, 2, 1]
    );
}

#[test]
fn test_206_2() {
    assert_eq!(
        Solution::reverse_list2(linked![1, 2, 3, 4, 5]),
        linked![5, 4, 3, 2, 1]
    );
}
```

#### 边界情况测试

```rust
// 空链表测试
assert_eq!(Solution::reverse_list(linked![]), linked![]);

// 单节点链表测试
assert_eq!(Solution::reverse_list(linked![1]), linked![1]);

// 双节点链表测试
assert_eq!(Solution::reverse_list(linked![1, 2]), linked![2, 1]);
```

#### 性能测试

```rust
#[test]
fn test_performance() {
    // 创建长链表测试
    let mut long_list = vec![];
    for i in 0..5000 {
        long_list.push(i);
    }
    
    let reversed = Solution::reverse_list(linked![long_list]);
    // 验证反转正确性
}
```

---

### 扩展思考

#### 相关题目

| 题号 | 名称 | 难度 | 核心技巧 |
| ------ | ------ | ------ | ---------- |
| 92 | Reverse Linked List II | 中等 | 部分反转链表 |
| 206 | Reverse Linked List | 简单 | 完整反转链表 |
| 234 | Palindrome Linked List | 简单 | 反转+快慢指针 |
| 25 | Reverse Nodes in k-Group | 困难 | 分组反转链表 |

#### 实际应用场景

1. **浏览器历史**：前进后退功能的链表反转
2. **撤销重做**：操作历史的反向遍历
3. **数据流处理**：需要反向处理的数据序列
4. **内存管理**：某些内存分配算法的链表操作

#### 算法变体

1. **部分反转**：反转链表的指定区间
2. **分组反转**：每k个节点为一组进行反转
3. **交替反转**：交替保留和反转节点
4. **递归反转**：使用递归实现更复杂的反转逻辑

---

### 常见错误与调试技巧

#### 常见错误

1. **空指针异常**：未正确处理空链表情况
2. **指针丢失**：反转过程中丢失后续节点引用
3. **循环链表**：指针设置错误导致循环引用
4. **内存泄漏**：未正确释放节点内存

#### 调试技巧

1. **可视化调试**：绘制链表状态图
2. **步进跟踪**：逐步执行观察指针变化
3. **边界测试**：重点测试空链表和单节点情况
4. **内存检查**：使用工具检查内存泄漏

---

## 小结

**核心技巧**：

- **三指针法**：pre、cur、temp 指针的协同操作
- **指针反转**：改变节点间的指向关系
- **所有权管理**：Rust 特有的内存安全机制

**关键实现细节**：

- 迭代法的循环终止条件
- 递归法的基本情况处理
- 指针所有权的安全转移

**学习方法论**：

1. **理解指针操作**：掌握链表节点的指针关系
2. **可视化思维**：在脑中构建链表反转过程
3. **多解法对比**：理解迭代和递归的优劣
4. **边界情况处理**：重视空链表和单节点情况

**重点关注**：

| 知识点 | 重要性 | 学习建议 |
| -------- | -------- | ---------- |
| 指针操作原理 | ⭐⭐⭐⭐⭐ | 理解内存地址和引用关系 |
| 迭代法实现 | ⭐⭐⭐⭐ | 掌握循环控制和指针更新 |
| 递归法实现 | ⭐⭐⭐⭐ | 理解递归栈和尾递归优化 |
| Rust所有权 | ⭐⭐⭐⭐ | 掌握take()和所有权转移 |
| 边界条件处理 | ⭐⭐⭐ | 学会处理各种特殊情况 |

**工程实践建议**：

1. **性能优先选择迭代法**：避免递归栈溢出风险
2. **代码可读性选择递归法**：逻辑更清晰简洁
3. **添加详细注释**：说明指针操作的关键步骤
4. **完善测试用例**：覆盖各种边界情况

**算法思维提升**：

- **指针操作思维**：理解内存地址和引用关系
- **递归思维**：将问题分解为相同结构的子问题
- **迭代思维**：通过循环逐步解决问题
- **抽象思维**：将具体操作抽象为通用模式

**进阶思考**：

1. 如何优化递归法的空间复杂度？
2. 反转双向链表与单链表有何不同？
3. 如何在反转过程中保持其他节点属性？
4. 反转算法的时间复杂度能否优化到O(1)？
