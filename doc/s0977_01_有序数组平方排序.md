# Squares of a Sorted Array（有序数组平方排序）

## 题解

---

### 问题描述

给定一个按非递减顺序排序的整数数组 `nums`，返回每个数字的平方组成的新数组，要求也按非递减顺序排序。

示例：

```text
输入：nums = [-4,-1,0,3,10]
输出：[0,1,9,16,100]
解释：平方后，数组变为 [16,1,0,9,100]。
排序后，数组变为 [0,1,9,16,100]。
```

---

### 多种实现方法比较

#### 1. 直接解法：平方后排序（O(n log n)）

```rust
impl Solution {
    pub fn sorted_squares1(nums: Vec<i32>) -> Vec<i32> {
        let mut squared: Vec<i32> = nums.iter().map(|&x| x * x).collect();
        squared.sort();
        squared
    }
}
```

**特点**：

- 时间复杂度：O(n log n)
- 排序操作占主导
- 空间复杂度：O(n) - 需要存储平方后的数组
- 实现简单直观，但效率较低

#### 2. 双指针优化版本（O(n)）- 现有实现

```rust
impl Solution {
    pub fn sorted_squares(nums: Vec<i32>) -> Vec<i32> {
        let mut n = nums.len();
        let mut ans = vec![0; n];
        let mut l = 0;
        let mut r = n;
        while l < r {
            if -nums[l] > nums[r - 1] {
                ans[n - 1] = nums[l] * nums[l];
                l += 1;
            } else {
                ans[n - 1] = nums[r - 1] * nums[r - 1];
                r -= 1;
            }
            n -= 1;
        }
        ans
    }
}
```

**特点**：

- 时间复杂度：O(n) - 单次遍历
- 空间复杂度：O(n) - 结果数组
- 利用数组已排序特性，比较绝对值大小
- 从结果数组末尾向前填充

#### 3. 双指针优化版本（O(n)）- 用户提供版本（有bug）

```rust
impl Solution {
    pub fn sorted_squares(nums: Vec<i32>) -> Vec<i32> {
        let n = nums.len();
        let mut ans = vec![0; n];
        let mut i = 0;
        let mut j = n - 1;
        for p in (0..n).rev() {
            let x = nums[i] * nums[i];
            let y = nums[j] * nums[j];
            if x > y {
                ans[p] = x;
                i += 1;
            } else {
                ans[p] = y;
                j -= 1;
            }
        }
        ans
    }

```

### 最佳写法

```rust
impl Solution {
    pub fn sorted_squares(nums: Vec<i32>) -> Vec<i32> {
        let mut n = nums.len();
        let mut ans = vec![0; n];
        let mut l = 0;
        let mut r = n;
        for i in (0..n).rev() {
            let x = -nums[l];
            let y = nums[r - 1];
            if x > y {
                ans[i] = x * x;
                l += 1;
            } else {
                ans[i] = y * y;
                r -= 1;
            }
        }
        ans
    }
}
```

### 总结

- 使用-nums[l] > nums[r - 1] 比较绝对值大小，避免了一次平方操作。
- 使用局部变量 `x` 和 `y` 存储平方值，避免重复计算，增加寄存器利用效率，而不是每次都从缓冲中加载。
- 在使用for循环时，通过 `(0..n).rev()` 可以避免使用 `while` 循环，减少了条件判断的次数,通过静态分析可以移除索引检查，提高效率。
- r = n 就算改写为循环，也不会发生下溢，因为r是判断过的数组元素

### 复杂度分析

| 类型 | 所有优化版本 |
|------|------------|
| 时间复杂度 | O(n)，只需一次遍历 |
| 空间复杂度 | O(n)，需要结果数组存储 |

---
