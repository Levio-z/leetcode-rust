# 2. Add Two Numbers (两数相加)

## 问题描述

给你两个非空链表，表示两个非负整数。数字以相反的顺序存储，每个节点包含一个数字。将这两个数字相加，并以相同形式返回一个表示和的链表。你可以假设这两个数字都不包含任何前导零，除了数字 0 本身。

### 示例

- **示例 1**：
  - 输入：l1 = [2,4,3], l2 = [5,6,4]
  - 输出：[7,0,8]
  - 解释：342 + 465 = 807。

- **示例 2**：
  - 输入：l1 = [0], l2 = [0]
  - 输出：[0]

- **示例 3**：
  - 输入：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]
  - 输出：[8,9,9,9,0,0,0,1]

### 约束条件

- 每个链表中的节点数在范围 [1, 100] 内
- 0 ≤ Node.val ≤ 9
- 题目数据保证列表表示的数字不含前导零

## 实现思路

两数相加问题可以通过链表的遍历和进位处理来解决。由于数字是以相反的顺序存储在链表中的，我们可以从链表的头部开始逐位相加，这正好对应数字的个位、十位、百位等从低到高的顺序。

### 实现方式概述

1. **迭代实现**：
   - 使用虚拟头节点（dummy）简化边界情况处理
   - 遍历两个链表，逐位相加并处理进位
   - 当其中一个链表遍历结束后，继续处理另一个链表的剩余节点和可能的进位

2. **递归实现**：
   - 将进位作为参数传递给递归函数
   - 递归处理链表的下一个节点
   - 当两个链表都遍历结束且没有进位时，递归终止

## 实现代码

### 链表节点定义

```rust
#[derive(PartialEq, Eq, Clone, Debug)]
pub struct ListNode {
  pub val: i32,
  pub next: Option<Box<ListNode>>
}

impl ListNode {
  #[inline]
  fn new(val: i32) -> Self {
    ListNode {
      next: None,
      val
    }
  }
}
```

### AddTwoNumbers 特质定义

```rust
trait AddTwoNumbers {
    fn add_two_numbers(
        l1: Option<Box<ListNode>>,
        l2: Option<Box<ListNode>>,
    ) -> Option<Box<ListNode>>;
}
```

### 迭代实现

```rust
pub struct Solution {}

impl AddTwoNumbers for Solution {
    fn add_two_numbers(
        mut l1: Option<Box<ListNode>>,
        mut l2: Option<Box<ListNode>>,
    ) -> Option<Box<ListNode>> {
        let mut dummy = Box::new(ListNode::new(0));
        let mut cur = &mut dummy;
        let mut carry = 0;
        
        while l1.is_some() || l2.is_some() || carry != 0 {
            let mut sum = carry;
            
            // 处理l1节点
            if let Some(node) = l1 {
                sum += node.val;
                l1 = node.next;
            }
            
            // 处理l2节点
            if let Some(node) = l2 {
                sum += node.val;
                l2 = node.next;
            }
            
            // 计算进位和当前位的值
            carry = sum / 10;
            cur.next = Some(Box::new(ListNode::new(sum % 10)));
            cur = cur.next.as_mut().unwrap();
        }
        
        dummy.next.take()
    }
}
```

### 递归实现

```rust
pub struct SolutionRecursive {}

impl SolutionRecursive {
    fn add_two_numbers_recursive(
        l1: Option<Box<ListNode>>,
        l2: Option<Box<ListNode>>,
        val: i32,
    ) -> Option<Box<ListNode>> {
        match (l1, l2, val) {
            // 两个链表都为空且没有进位，递归终止
            (None, None, 0) => None,
            // 两个链表都为空但有进位，创建新节点
            (None, None, val) => Some(Box::new(ListNode::new(val))),
            // l1有节点，l2为空
            (Some(node), None, val) => Some(Box::new(ListNode {
                val: (node.val + val) % 10,
                next: Self::add_two_numbers_recursive(node.next, None, (node.val + val) / 10),
            })),
            // l2有节点，l1为空，转换为l1有节点的情况
            (None, Some(node), val) => Self::add_two_numbers_recursive(Some(node), None, val),
            // 两个链表都有节点
            (Some(node1), Some(node2), val) => Some(Box::new(ListNode {
                val: (node1.val + node2.val + val) % 10,
                next: Self::add_two_numbers_recursive(
                    node1.next,
                    node2.next,
                    (node1.val + node2.val + val) / 10,
                ),
            })),
        }
    }
}

impl AddTwoNumbers for SolutionRecursive {
    fn add_two_numbers(
        l1: Option<Box<ListNode>>,
        l2: Option<Box<ListNode>>,
    ) -> Option<Box<ListNode>> {
        Self::add_two_numbers_recursive(l1, l2, 0)
    }
}
```

## 实现分析

### 迭代实现

1. **核心思路**：
   - 使用虚拟头节点（dummy）简化链表操作，避免单独处理头节点的情况
   - 遍历两个链表，逐位相加并处理进位
   - 循环条件包含了处理进位的情况，确保所有进位都被正确处理

2. **代码细节**：
   - `dummy`：虚拟头节点，其`next`指向结果链表的第一个节点
   - `cur`：当前指针，用于构建结果链表
   - `carry`：进位值，初始化为0
   - `while`循环条件：`l1.is_some() || l2.is_some() || carry != 0`，确保处理完所有节点和进位
   - 使用`if let Some(node) = l1`模式匹配获取节点值，并更新链表指针
   - `sum % 10`：计算当前位的值
   - `sum / 10`：计算进位值
   - `dummy.next.take()`：返回结果链表（跳过虚拟头节点）

3. **性能分析**：
   - 时间复杂度：O(max(m, n))，其中m和n分别是两个链表的长度
   - 空间复杂度：O(1)，不考虑结果链表的空间，仅使用了常数个额外变量

### 递归实现

1. **核心思路**：
   - 将进位作为参数传递给递归函数
   - 通过模式匹配处理不同的链表状态（都为空、一个为空、都不为空）
   - 递归调用处理链表的下一个节点，直到两个链表都为空且没有进位

2. **代码细节**：
   - `add_two_numbers_recursive`：递归函数，接收两个链表和进位值作为参数
   - 模式匹配`match (l1, l2, val)`处理四种情况：
     - 两个链表都为空且没有进位：返回None，递归终止
     - 两个链表都为空但有进位：创建新节点并返回
     - l1有节点，l2为空：计算当前位和进位，递归处理l1的下一个节点
     - l2有节点，l1为空：转换为l1有节点的情况
     - 两个链表都有节点：计算当前位和进位，递归处理两个链表的下一个节点
   - `add_two_numbers`：对外接口，调用递归函数并初始进位为0

3. **性能分析**：
   - 时间复杂度：O(max(m, n))，其中m和n分别是两个链表的长度
   - 空间复杂度：O(max(m, n))，递归调用栈的深度

## 两种实现方式的比较

| 实现方式 | 优点 | 缺点 | 适用场景 |
|---------|------|------|----------|
| 迭代实现 | 空间复杂度低（O(1)），性能稳定 | 代码略复杂，需要管理指针 | 对空间要求较高的场景 |
| 递归实现 | 代码简洁，逻辑清晰 | 空间复杂度较高（O(max(m, n))），可能导致栈溢出 | 链表较短的场景，追求代码简洁性 |

## 测试用例

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use crate::util::linked_list::{ListNode, to_list};

    #[test]
    fn test_2() {
        let l1 = to_list(vec![2, 4, 9]);
        let l2 = to_list(vec![5, 6, 4]);
        let res = to_list(vec![7, 0, 4, 1]);
        assert_eq!(Solution::add_two_numbers(l1, l2), res);
    }
    
    #[test]
    fn test_2_recursive() {
        let l1 = to_list(vec![2, 4, 9]);
        let l2 = to_list(vec![5, 6, 4]);
        let res = to_list(vec![7, 0, 4, 1]);
        assert_eq!(SolutionRecursive::add_two_numbers(l1, l2), res);
    }
}
```

## 扩展思考

### 其他可能的实现方式

1. **尾递归优化**：
   - 对递归实现进行尾递归优化，以减少栈空间的使用
   - Rust目前还不支持自动尾递归优化，需要手动实现

2. **使用额外的数据结构**：
   - 可以将链表转换为数字进行相加，然后再转换回链表
   - 但这种方法可能会遇到数值溢出的问题，不适合处理大数字

### 性能优化考虑

1. **提前终止**：
   - 当其中一个链表遍历结束且没有进位时，可以直接将另一个链表的剩余部分连接到结果链表
   - 这可以减少不必要的循环或递归调用

2. **内存分配优化**：
   - 可以预分配结果链表的节点，减少内存分配的次数
   - 或者复用输入链表的节点，以减少内存使用

### 与其他问题的关联

1. **两数相加 II**：
   - 与本题类似，但数字是以正序存储的
   - 需要先反转链表，或者使用栈来处理

2. **二进制链表转整数**：
   - 将链表表示的二进制数转换为整数
   - 与本题的数字表示方式类似，但基数不同

3. **链表的中间节点**：
   - 寻找链表的中间节点
   - 涉及链表的遍历操作

## 总结

本问题提供了两种有效的解决方案：迭代实现和递归实现。

迭代实现的优点是空间复杂度低，性能稳定，适合处理较长的链表。它使用虚拟头节点简化了边界情况的处理，并通过循环遍历链表逐位相加。

递归实现的优点是代码简洁，逻辑清晰，适合处理较短的链表。它通过递归调用处理链表的下一个节点，并将进位作为参数传递。

在实际应用中，应根据链表的长度和对空间的要求选择合适的实现方式。对于较长的链表，迭代实现可能是更好的选择；对于较短的链表，递归实现可能更易于理解和维护。

两种实现方式都展示了链表操作的基本技巧，包括虚拟头节点的使用、指针的管理、进位的处理等。这些技巧在解决其他链表相关问题时也经常用到。
