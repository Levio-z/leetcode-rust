# 541. 反转字符串 II

## 问题描述

给定一个字符串 s 和一个整数 k，从字符串开头算起，每计数至 2k 个字符，就反转这 2k 字符中的前 k 个字符。如果剩余字符少于 k 个，则将剩余字符全部反转。如果剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符，其余字符保持原样。

### 示例

- **示例 1**：
  - 输入：`s = "abcdefg", k = 2`
  - 输出：`"bacdfeg"`

- **示例 2**：
  - 输入：`s = "abcd", k = 2`
  - 输出：`"bacd"`

### 约束条件

- `1 <= s.length <= 10^4`
- `s` 仅由小写英文字母组成
- `1 <= k <= 10^4`

## 实现思路

### 方法概述

按 2k 为步长遍历字符串，对每个区间内的前 k 个字符进行反转。提供两种实现：基于 `chars` 的安全版本和基于 `bytes` 的高效版本。

### 代码实现

```rust
impl Solution {
    // 方法一：基于 chars（安全，支持 Unicode）
    pub fn reverse_str(mut s: String, k: i32) -> String {
        let mut chars: Vec<char> = s.chars().collect();
        let n = chars.len();
        for i in (0..n).step_by(2 * k as usize) {
            let end = (i + k as usize).min(n);
            chars[i..end].reverse();
        }
        chars.into_iter().collect()
    }

    // 方法二：基于 bytes（高效，仅适用于 ASCII）
    pub fn reverse_str_byts(mut s: String, k: i32) -> String {
        let bytes = unsafe { s.as_bytes_mut() };
        let k: usize = k as usize;
        let n: usize = bytes.len();
        for i in (0..n).step_by(2 * k) {
            bytes[i..n.min(i + k)].reverse();
        }
        s
    }

    // 辅助函数：手动反转字节切片
    // 中文字符一般占 3 个字节（如 "你" → [0xE4, 0xBD, 0xA0]）
    // Emoji 占 4 个字节甚至更多
    // ASCII 仍然占 1 个字节
    fn reverse_str_pre(s: &mut [u8], i: usize, k: i32) {
        let mut i = i;
        let mut j = std::cmp::min(i + k as usize, s.len()) - 1;
        while i < j {
            s.swap(i, j);
            i += 1;
            j -= 1;
        }
    }
}
```

## 实现分析

### 核心思路

1. 使用 `step_by(2 * k)` 按 2k 步长遍历
2. 计算每个区间的结束位置：`min(i + k, n)`
3. 使用切片的 `reverse()` 方法原地反转

### 代码细节

- `step_by(2 * k)` 直接生成需要处理的起始位置
- `.min(n)` 处理末尾不足 k 个字符的情况
- `chars` 版本支持 Unicode，`bytes` 版本仅支持 ASCII
- `unsafe { s.as_bytes_mut() }` 可以直接修改字符串底层字节

### 性能分析

| 方法 | 时间复杂度 | 空间复杂度 | 说明 |
|------|--------|--------|------|
| chars 版本 | O(n) | O(n) | 需要收集到 Vec |
| bytes 版本 | O(n) | O(1) | 原地修改，更高效 |

## 测试用例

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_541() {
        assert_eq!(
            Solution::reverse_str("abcdefg".to_string(), 2),
            "bacdfeg".to_string()
        );
    }
}
```

## 扩展思考

### Unicode 注意事项

- 中文字符占 3 个字节
- Emoji 占 4 个字节或更多
- ASCII 字符占 1 个字节
- `bytes` 版本对非 ASCII 字符使用 `unsafe`，需确保输入仅包含 ASCII

### 其他可能的实现方式

1. **使用 chunks_mut**：
   - `chars.chunks_mut(2 * k)` 分块处理
   - 代码更简洁

2. **递归实现**：
   - 每次处理 2k 字符后递归处理剩余部分
   - 不推荐，增加栈开销

## 总结

1. `step_by` 是处理固定步长遍历的利器
2. 对于纯 ASCII 字符串，`bytes` 版本性能更优
3. 切片的 `reverse()` 方法简洁高效
4. 注意边界条件：剩余字符少于 k 的情况
