# 454. 4Sum II (四数相加 II)

## 问题描述

给定四个整数数组 `nums1`、`nums2`、`nums3` 和 `nums4`，它们的长度都相同。返回满足以下条件的元组 `(i, j, k, l)` 的数量：

1. `0 <= i, j, k, l < n`（其中n是数组长度）
2. `nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0`

### 示例

- **示例 1**：
  - 输入：`nums1 = [1,2], nums2 = [-2,-1], nums3 = [-1,2], nums4 = [0,2]`
  - 输出：`2`
  - 解释：
    - 元组1：(0, 0, 0, 1) -> 1 + (-2) + (-1) + 2 = 0
    - 元组2：(1, 1, 0, 0) -> 2 + (-1) + (-1) + 0 = 0

- **示例 2**：
  - 输入：`nums1 = [0], nums2 = [0], nums3 = [0], nums4 = [0]`
  - 输出：`1`

### 约束条件

- 所有数组的长度都相同，记为n
- `1 <= n <= 200`
- `-2^28 <= nums1[i], nums2[i], nums3[i], nums4[i] <= 2^28`

## 实现思路

4Sum II问题是一个典型的查找问题，可以通过哈希表来优化时间复杂度。核心思路是将四个数组分成两组，计算前两组的所有可能和并记录出现次数，然后在后两组中查找是否存在对应的相反数。

### 实现方式概述

1. **分组策略**：将四个数组分为两组，`nums1`和`nums2`为一组，`nums3`和`nums4`为另一组
2. **哈希表统计**：使用哈希表记录前两组所有可能的和及其出现次数
3. **查找匹配**：遍历后两组的所有可能和，在哈希表中查找其相反数，累加对应的出现次数

## 实现代码

```rust
impl Solution {
    pub fn four_sum_count(
        nums1: Vec<i32>,
        nums2: Vec<i32>,
        nums3: Vec<i32>,
        nums4: Vec<i32>,
    ) -> i32 {
        let mut cnt = HashMap::new();
        // 统计nums1和nums2所有可能和的出现次数
        for &x in nums1.iter() {
            for &y in nums2.iter() {
                *cnt.entry(x + y).or_insert(0) += 1;
            }
        }
        let mut ans = 0;
        // 在nums3和nums4中查找匹配的和
        for &x in nums3.iter() {
            for &y in nums4.iter() {
                ans += cnt.get(&(-(x + y))).unwrap_or(&0);
            }
        }
        ans
    }
}
```

## 实现分析

### 核心思路

1. **分组与哈希表统计**：
   - 将四个数组分成两组，分别计算每组的所有可能和
   - 这样可以将时间复杂度从O(n⁴)降低到O(n²)
   - 使用哈希表`cnt`记录`nums1[i] + nums2[j]`的所有可能值及其出现次数

2. **查找匹配**：
   - 对于`nums3[k] + nums4[l]`的每个可能值，计算其相反数`-(nums3[k] + nums4[l])`
   - 在哈希表中查找该相反数出现的次数，累加到结果中
   - 这样就找到了所有满足`nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0`的元组

### 代码细节

1. **哈希表操作**：
   - `entry(x + y)`：获取哈希表中键为`x + y`的条目
   - `or_insert(0)`：如果键不存在，则插入默认值0
   - `*cnt.entry(...) += 1`：对找到或插入的键值加1

2. **查找与累加**：
   - `-(x + y)`：计算当前和的相反数
   - `cnt.get(...)`：在哈希表中查找该相反数
   - `unwrap_or(&0)`：如果找不到则返回0，避免panic
   - `ans += ...`：累加匹配的次数

### 性能分析

1. **时间复杂度**：O(n²)
   - 遍历`nums1`和`nums2`的所有组合：O(n²)
   - 遍历`nums3`和`nums4`的所有组合：O(n²)
   - 哈希表的插入和查找操作平均时间复杂度为O(1)

2. **空间复杂度**：O(n²)
   - 在最坏情况下，`nums1`和`nums2`的所有组合和都不相同
   - 此时哈希表需要存储n²个键值对

## 测试用例

```rust
#[test]
fn test_454() {
    // 测试示例1：两组和的组合匹配
    assert_eq!(
        Solution::four_sum_count(vec![1, 2], vec![-2, -1], vec![-1, 2], vec![0, 2]),
        2
    );
}
```

## 扩展思考

### 其他可能的实现方式

1. **分组方式的选择**：
   - 除了`(nums1, nums2)`和`(nums3, nums4)`的分组方式外，还可以选择其他分组方式，如`(nums1, nums3)`和`(nums2, nums4)`
   - 不同的分组方式不会影响时间复杂度，但可能会影响哈希表的大小（取决于数组元素的分布）

2. **扩展到k数相加**：
   - 对于k个数组的情况，可以采用类似的分组策略，将k个数组分成两部分
   - 当k为偶数时，分成两组，每组k/2个数组
   - 当k为奇数时，可以将其中一个数组单独处理，或者将k-1个数组分成两组，再与最后一个数组组合

3. **使用其他数据结构**：
   - 在某些情况下，可以使用其他数据结构如平衡二叉搜索树来替代哈希表
   - 这可能会增加时间复杂度（O(log n)的插入和查找），但可以保证数据的有序性，在某些特定场景下可能有用

### 性能优化考虑

1. **数组长度检查**：
   - 在开始计算之前，可以检查四个数组的长度是否相同
   - 如果长度不同，可以直接返回0

2. **空数组处理**：
   - 如果任意一个数组为空，可以直接返回0

3. **哈希表容量预分配**：
   - 在创建哈希表时，可以预分配足够的容量（如n*n）
   - 这可以减少哈希表扩容的次数，提高性能

4. **并行计算**：
   - 对于非常大的n，可以考虑使用并行计算来加速前两组和的统计
   - 这需要使用多线程或并行计算框架

### 与其他问题的关联

1. **4Sum问题**：
   - 4Sum II与4Sum问题类似，但4Sum问题要求在一个数组中找到四个元素，而4Sum II是在四个数组中各取一个元素
   - 4Sum问题通常需要排序和双指针技术，而4Sum II更适合使用哈希表

2. **Two Sum问题**：
   - 4Sum II可以看作是Two Sum问题的扩展
   - Two Sum问题是在一个数组中找到两个元素之和等于目标值
   - 4Sum II可以通过分组转化为两个Two Sum问题

## 总结

本问题提供了一种高效的解决方案，通过哈希表和分组策略将时间复杂度从O(n⁴)降低到O(n²)。核心思想是将四个数组分成两组，分别计算每组的所有可能和，然后使用哈希表查找匹配的组合。

这种方法的优点是：

1. 时间复杂度较低，适合处理较大的输入
2. 实现简单，易于理解和维护
3. 可以方便地扩展到k数相加的情况

在实际应用中，这种分组和哈希表结合的方法可以用于解决各种组合求和问题，特别是当需要处理多个数据集的组合时。
