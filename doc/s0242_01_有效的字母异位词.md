# 242. Valid Anagram (有效的字母异位词)

## 问题描述

给定两个字符串 `s` 和 `t`，判断 `t` 是否是 `s` 的**字母异位词**。字母异位词指字母相同，但排列不同的字符串。

### 示例

- **示例 1**：
  - 输入：`s = "anagram", t = "nagaram"`
  - 输出：`true`

- **示例 2**：
  - 输入：`s = "rat", t = "car"`
  - 输出：`false`

### 约束条件

- `1 <= s.length, t.length <= 5 * 10^4`
- `s` 和 `t` 仅包含小写英文字母

### 进阶问题

如果输入字符串包含 Unicode 字符，该如何调整解决方案？

## 实现思路

字母异位词的核心特征是：两个字符串包含的字符种类和数量完全相同，只是排列顺序不同。因此，我们可以通过统计两个字符串中每个字符的出现次数，然后比较这些统计结果是否一致来解决问题。

### 实现方式概述

1. **数组统计法**：利用字符集的有限性（小写英文字母），使用固定大小的数组来统计字符出现次数
2. **哈希表统计法**：使用哈希表来统计字符出现次数，适用于更广泛的字符集

## 实现代码

### 数组统计法

```rust\pub fn is_anagram(s: String, t: String) -> bool {
    let mut byte = [0; 26];
    s.bytes().for_each(|b| byte[(b - b'a') as usize] += 1);
    t.bytes().for_each(|b| byte[(b - b'a') as usize] -= 1);
    byte.iter().all(|x| *x == 0)
}
```

### 哈希表统计法

```rust\pub fn is_anagram2(s: String, t: String) -> bool {
    let mut byte = std::collections::HashMap::new();
    s.bytes().for_each(|b| *byte.entry(b).or_insert(0) += 1);
    t.bytes().for_each(|b| *byte.entry(b).or_insert(0) -= 1);
    byte.iter().all(|(_, x)| *x == 0)
}
```

## 实现分析

### 数组统计法

1. **核心思路**：
   - 由于输入仅包含小写英文字母，可以使用一个大小为26的数组来分别统计每个字母的出现次数
   - 遍历字符串`s`，对每个字符对应的数组位置加1
   - 遍历字符串`t`，对每个字符对应的数组位置减1
   - 最后检查数组中的所有元素是否都为0，若为0则说明两个字符串是字母异位词

2. **代码细节**：
   - `b'a'`表示字符'a'的ASCII值，通过`b - b'a'`可以将小写字母映射到0-25的索引
   - 使用`bytes()`方法将字符串转换为字节迭代器，方便处理
   - `for_each()`方法用于遍历迭代器并执行指定操作
   - `all()`方法检查数组中所有元素是否都满足条件（等于0）

3. **性能分析**：
   - 时间复杂度：O(n)，其中n是字符串的长度。需要遍历两个字符串各一次，以及遍历数组一次（固定26次操作）
   - 空间复杂度：O(1)，使用了固定大小的数组（26个元素），与输入规模无关

### 哈希表统计法

1. **核心思路**：
   - 使用哈希表（HashMap）来统计每个字符的出现次数，适用于任意字符集
   - 遍历字符串`s`，对每个字符对应的哈希表键值加1
   - 遍历字符串`t`，对每个字符对应的哈希表键值减1
   - 最后检查哈希表中所有键对应的值是否都为0

2. **代码细节**：
   - 使用`entry()`方法获取哈希表中指定键的条目
   - `or_insert(0)`方法在键不存在时插入默认值0
   - 通过解引用操作符`*`来修改哈希表中的值

3. **性能分析**：
   - 时间复杂度：O(n)，其中n是字符串的长度。需要遍历两个字符串各一次，以及遍历哈希表一次
   - 空间复杂度：O(k)，其中k是字符集的大小。在最坏情况下，k可能等于n

## 两种实现方式的比较

| 实现方式 | 优点 | 缺点 | 适用场景 |
|---------|------|------|----------|
| 数组统计法 | 时间效率高，空间占用固定且小 | 仅适用于已知大小的字符集 | 输入仅包含小写英文字母等有限字符集的情况 |
| 哈希表统计法 | 适用范围广，可处理任意字符集 | 时间效率略低于数组，空间占用较大 | 输入包含Unicode等任意字符集的情况 |

## 测试用例

```rust
#[test]
fn test_242() {
    // 测试示例1：有效的字母异位词
    assert!(Solution::is_anagram("anagram".to_string(), "nagaram".to_string()));
    // 测试示例2：无效的字母异位词
    assert!(!Solution::is_anagram("rat".to_string(), "car".to_string()));
}

#[test]
fn test_242_2() {
    // 测试哈希表实现的示例1
    assert!(Solution::is_anagram2("anagram".to_string(), "nagaram".to_string()));
    // 测试哈希表实现的示例2
    assert!(!Solution::is_anagram2("rat".to_string(), "car".to_string()));
}
```

## 扩展思考

### 进阶问题解答：处理Unicode字符

如果输入字符串包含Unicode字符，数组统计法将不再适用，因为Unicode字符集非常大且不连续。此时，哈希表统计法是更好的选择，因为它可以动态地适应任意字符集。

### 其他可能的实现方式

1. **排序比较法**：
   - 将两个字符串分别排序，然后比较排序后的字符串是否相等
   - 时间复杂度：O(n log n)，其中n是字符串的长度
   - 空间复杂度：O(n)，需要额外的空间存储排序后的字符串

2. **位运算**：
   - 对于仅包含小写英文字母的情况，可以使用位运算来存储字符出现的信息
   - 但这种方法无法统计字符出现的次数，只能判断字符是否出现
   - 因此，这种方法不适用于本题，但在其他类似问题中可能有用

### 性能优化考虑

1. **长度检查**：在开始统计字符出现次数之前，可以先检查两个字符串的长度是否相等。如果长度不相等，直接返回false

2. **提前退出**：在遍历第二个字符串时，如果发现某个字符的统计值已经小于0，可以提前返回false

## 总结

本问题提供了两种有效的解决方案：

1. **数组统计法**是针对小写英文字母的最优解，具有O(n)的时间复杂度和O(1)的空间复杂度
2. **哈希表统计法**是更通用的解决方案，适用于任意字符集，同样具有O(n)的时间复杂度，但空间复杂度略高

在实际应用中，应根据输入字符集的特点选择合适的解决方案。对于题目中给定的约束条件（仅包含小写英文字母），数组统计法是更好的选择。而对于进阶问题（包含Unicode字符），哈希表统计法则是唯一可行的方案。
