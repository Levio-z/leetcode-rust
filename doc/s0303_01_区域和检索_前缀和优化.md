# Range Sum Query - Immutable（前缀和优化）

## 题解

---

### 问题描述

设计一个数据结构，能够高效处理多个区间和查询。给定一个整数数组 `nums`，需要实现以下功能：

* `NumArray(nums)`：使用整数数组初始化对象
* `sum_range(left, right)`：返回数组在区间 `[left, right]` 内元素的和

**示例**：

```text
输入：
["NumArray", "sumRange", "sumRange", "sumRange"]
[[[-2, 0, 3, -5, 2, -1]], [0, 2], [2, 5], [0, 5]]

输出：
[null, 1, -1, -3]

解释：
NumArray numArray = new NumArray([-2, 0, 3, -5, 2, -1]);
numArray.sumRange(0, 2); // 返回 (-2) + 0 + 3 = 1
numArray.sumRange(2, 5); // 返回 3 + (-5) + 2 + (-1) = -1
numArray.sumRange(0, 5); // 返回 (-2) + 0 + 3 + (-5) + 2 + (-1) = -3
```

**约束条件**：

* 数组长度：1 ≤ nums.length ≤ 10⁴
* 元素范围：-10⁵ ≤ nums[i] ≤ 10⁵
* 查询次数：最多 10⁴ 次 sumRange 调用

---

### 思路演变：从暴力解到前缀和优化

#### 1. 暴力解法（直接累加）

每次查询时直接遍历区间进行累加：

```rust
struct NumArray {
    nums: Vec<i32>,
}

impl NumArray {
    fn new(nums: Vec<i32>) -> Self {
        Self { nums }
    }
    
    fn sum_range(&self, left: i32, right: i32) -> i32 {
        let (l, r) = (left as usize, right as usize);
        self.nums[l..=r].iter().sum()
    }
}
```

**复杂度分析**：

* 时间复杂度：O(n) 每次查询，m次查询总复杂度 O(mn)
* 空间复杂度：O(1) 额外空间

**问题**：当查询次数 m 很大时（最多 10⁴ 次），总时间复杂度 O(mn) 可能达到 10⁸，在约束条件下可能超时。

#### 2. 前缀和优化（空间换时间）

**核心思想**：预处理前缀和数组，将区间和查询转换为两次数组访问。

```rust
struct NumArray {
    prefix: Vec<i32>,  // prefix[i] 表示 nums[0..i] 的和
}

impl NumArray {
    fn new(nums: Vec<i32>) -> Self {
        let mut prefix = vec![0; nums.len() + 1];
        for i in 0..nums.len() {
            prefix[i + 1] = prefix[i] + nums[i];
        }
        Self { prefix }
    }
    
    fn sum_range(&self, left: i32, right: i32) -> i32 {
        let (l, r) = (left as usize, right as usize);
        self.prefix[r + 1] - self.prefix[l]
    }
}
```

**数学原理**：

---

### 算法对比

| 方法 | 预处理时间 | 查询时间 | 总时间(m次查询) | 空间复杂度 | 适用场景 |
|------|------------|----------|-----------------|------------|----------|
| 暴力累加 | O(1) | O(n) | O(mn) | O(1) | 查询次数少 |
| 前缀和 | O(n) | O(1) | O(n + m) | O(n) | 查询次数多 |

**选择依据**：当查询次数 m ≫ 1 时，前缀和方法明显更优。

---

### 复杂度分析

| 操作 | 时间复杂度 | 空间复杂度 |
|------|------------|------------|
| 构造函数 | O(n) | O(n) |
| 单次查询 | O(1) | O(1) |
| m次查询 | O(n + m) | O(n) |

**优化效果**：将 m 次查询的总时间复杂度从 O(mn) 优化到 O(n + m)。

---

### 测试用例设计

#### 基础测试

```rust
#[test]
fn test_basic() {
    let nums = vec![-2, 0, 3, -5, 2, -1];
    let num_array = NumArray::new(nums);
    assert_eq!(num_array.sum_range(0, 2), 1);   // -2 + 0 + 3 = 1
    assert_eq!(num_array.sum_range(2, 5), -1); // 3 + (-5) + 2 + (-1) = -1
    assert_eq!(num_array.sum_range(0, 5), -3); // 全部元素和
}
```

#### 边界测试

```rust

```

#### 性能测试
```rust
#[test]
fn test_performance() {
    // 大数据量测试
    let nums: Vec<i32> = (0..10000).collect();
    let na = NumArray::new(nums);
    
    // 多次查询验证性能
    for _ in 0..1000 {
        assert_eq!(na.sum_range(0, 9999), 49995000);
    }
}
```

---

### 扩展思考

#### 相关题目

| 题号 | 名称 | 难度 | 核心技巧 |
|------|------|------|----------|
| 304 | Range Sum Query 2D - Immutable | 中等 | 二维前缀和 |
| 307 | Range Sum Query - Mutable | 中等 | 线段树/树状数组 |
| 560 | Subarray Sum Equals K | 中等 | 前缀和 + 哈希表 |
| 523 | Continuous Subarray Sum | 中等 | 前缀和取模 |

#### 算法变体

1. **二维前缀和**：扩展到矩阵区域和查询
2. **动态前缀和**：支持元素更新的情况（线段树、树状数组）
3. **前缀和哈希**：统计满足特定条件的子数组数量

#### 实际应用场景

* **数据分析**：快速计算时间序列数据的区间统计
* **图像处理**：计算图像区域的像素和
* **金融计算**：股票价格区间收益计算
* **游戏开发**：地图区域资源统计

---

## 小结

**核心技巧**：
* 前缀和数组将区间和查询从 O(n) 优化到 O(1)
* 典型的"空间换时间"优化策略
* 数学原理：区间和 = 右边界前缀和 - 左边界前缀和

**关键实现细节**：
* 前缀和数组长度设为 `n+1`，`prefix[0] = 0`
* 区间 `[left, right]` 的和 = `prefix[right+1] - prefix[left]`
* Rust 中注意索引类型转换和边界处理

**学习方法论**：
1. 识别查询密集型问题的特征
2. 考虑预处理优化策略
3. 掌握前缀和的基本数学原理
4. 理解空间换时间的权衡

**重点关注**：

| 知识点 | 重要性 | 学习建议 |
|--------|--------|----------|
| 前缀和数学原理 | ⭐⭐⭐⭐⭐ | 理解递推关系和区间转换 |
| 空间换时间策略 | ⭐⭐⭐⭐ | 分析时间空间复杂度权衡 |
| 边界条件处理 | ⭐⭐⭐⭐ | 注意数组索引和区间定义 |
| 扩展到高维 | ⭐⭐⭐ | 为后续二维前缀和打基础 |
