# Implement Trie (Prefix Tree)（字典树实现）

## 题解

---

### 问题描述

实现一个字典树（Trie，又称前缀树）数据结构，支持以下操作：

* `Trie()`：初始化字典树对象
* `insert(word)`：将字符串 `word` 插入字典树
* `search(word)`：如果字符串 `word` 在字典树中，返回 `true`；否则返回 `false`
* `startsWith(prefix)`：如果之前插入的字符串包含前缀 `prefix`，返回 `true`；否则返回 `false`

**示例**：

```text
输入：
["Trie", "insert", "search", "search", "startsWith", "insert", "search"]
[[], ["apple"], ["apple"], ["app"], ["app"], ["app"], ["app"]]

输出：
[null, null, true, false, true, null, true]

解释：
Trie trie = new Trie();
trie.insert("apple");
trie.search("apple");   // 返回 true
trie.search("app");     // 返回 false
trie.startsWith("app"); // 返回 true
trie.insert("app");
trie.search("app");     // 返回 true
```

**约束条件**：

* 1 ≤ word.length, prefix.length ≤ 2000
* 字符串仅包含小写英文字母
* 最多 3×10⁴ 次 insert、search、startsWith 调用

---

### 数据结构设计：字典树原理

#### 字典树基本概念

字典树是一种专门用于字符串检索的树形数据结构，具有以下特点：

1. **节点结构**：每个节点包含子节点数组和结束标志
2. **路径表示**：从根节点到某个节点的路径构成一个字符串
3. **前缀共享**：具有公共前缀的字符串共享路径

#### 节点结构设计

```rust
#[derive(Debug)]
struct TrieNode {
    children: [Option<Box<TrieNode>>; 26],  // 26个小写字母的子节点
    is_end: bool,                           // 是否单词结束
}

impl TrieNode {
    fn new() -> Self {
        TrieNode {
            children: Default::default(),   // 初始化26个None
            is_end: false,
        }
    }
}
```

**设计要点**：

* 使用固定大小数组（26个元素）存储子节点
* `Option<Box<TrieNode>>` 实现可选子节点和内存管理
* `is_end` 标记单词结束位置

---

### 核心算法实现

#### 1. 插入操作（insert）

```rust
fn insert(&mut self, word: String) {
    let mut node = &mut self.root;
    for c in word.bytes() {
        let index = (c - b'a') as usize;  // 字符映射到索引
        node = node.children[index].get_or_insert(Box::new(TrieNode::new()));
    }
    node.is_end = true;  // 标记单词结束
}
```

**执行流程**（插入 "apple"）：

1. 从根节点开始
2. 遍历字符：a → p → p → l → e
3. 为每个字符创建或获取对应子节点
4. 在最后一个字符节点设置 `is_end = true`

#### 2. 查找辅助方法（find）

```rust
fn find(&self, word: String) -> Option<&TrieNode> {
    let mut node = &self.root;
    for c in word.bytes() {
        let index = (c - b'a') as usize;
        match node.children[index] {
            None => return None,           // 路径不存在
            Some(ref child) => node = child, // 继续向下查找
        }
    }
    Some(node)  // 返回找到的节点
}
```

**功能**：查找字符串对应的节点，无论是否单词结束

#### 3. 精确查找（search）

```rust
fn search(&self, word: String) -> bool {
    self.find(word).is_some_and(|node| node.is_end)
}
```

**条件**：路径存在且结束标志为 `true`

#### 4. 前缀查找（starts_with）

```rust
fn starts_with(&self, prefix: String) -> bool {
    self.find(prefix).is_some()
}
```

**条件**：路径存在即可，不要求结束标志

---

### 复杂度分析

| 操作 | 时间复杂度 | 空间复杂度 | 说明 |
|------|------------|------------|------|

| 插入 | O(L) | O(L) | L为字符串长度 |
| 查找 | O(L) | O(1) | 仅需遍历路径 |
| 前缀查找 | O(L) | O(1) | 同查找操作 |

**空间复杂度优化**：

* **最坏情况**：O(AL)，A为字母表大小，L为总字符数
* **实际优化**：共享前缀减少存储空间

---

### 算法对比：不同实现方式

#### 1. 数组实现（当前方案）

**优点**：

* 访问速度快：O(1) 时间访问子节点
* 内存连续：缓存友好
* 实现简单：代码清晰易懂

**缺点**：

* 空间浪费：对于稀疏树浪费内存
* 固定大小：仅支持小写字母

#### 2. 哈希表实现

```rust
use std::collections::HashMap;

struct TrieNode {
    children: HashMap<char, TrieNode>,
    is_end: bool,
}
```

**优点**：

* 空间高效：仅存储存在的子节点
* 支持任意字符：不限于小写字母

**缺点**：

* 访问稍慢：哈希计算需要时间
* 内存不连续：缓存不友好

#### 3. 链表实现

**优点**：

* 极致空间节省：仅存储必要节点

**缺点**：

* 访问最慢：需要遍历链表
* 实现复杂：指针操作容易出错

---

### 扩展思考

#### 相关题目

| 题号 | 名称 | 难度 | 核心技巧 |
|------|------|------|----------|

| 211 | Design Add and Search Words Data Structure | 中等 | 字典树 + 通配符匹配 |
| 212 | Word Search II | 困难 | 字典树 + 回溯搜索 |
| 642 | Design Search Autocomplete System | 困难 | 字典树 + 热度排序 |
| 677 | Map Sum Pairs | 中等 | 字典树 + 前缀和计算 |

#### 实际应用场景

1. **搜索引擎**：自动补全和拼写检查
2. **输入法**：词库管理和联想输入
3. **路由系统**：IP地址最长前缀匹配
4. **生物信息学**：DNA序列模式匹配
5. **网络协议**：URL路由和过滤

#### 算法变体

1. **压缩字典树**：合并单路径节点，减少空间
2. **双数组字典树**：使用两个数组优化存储和访问
3. **后缀树**：支持后缀匹配的扩展结构
4. **AC自动机**：多模式匹配的字典树变体

---

### Rust 实现特色

#### 1. 内存安全设计

```rust
children: [Option<Box<TrieNode>>; 26]
```

* **Box指针**：确保堆分配和所有权明确
* **Option包装**：优雅处理空子节点
* **数组定长**：编译时大小确定，无动态分配

#### 2. 高效的字符处理

```rust
for c in word.bytes() {
    let index = (c - b'a') as usize;
}
```

* **字节迭代**：避免UTF-8解码开销
* **算术映射**：快速计算字符索引
* **边界安全**：仅处理小写字母，无需验证

#### 3. 函数式编程风格

```rust
self.find(word).is_some_and(|node| node.is_end)
```

* **组合操作**：链式调用提高可读性
* **条件判断**：`is_some_and` 优雅处理Option

---

## 小结

**核心技巧**：

* **树形结构**：使用树形结构高效存储字符串集合
* **前缀共享**：利用公共前缀减少存储空间
* **路径表示**：节点路径自然表示字符串

**关键实现细节**：

* 子节点数组的索引计算：`(c - b'a') as usize`
* 结束标志的正确设置：仅在单词末尾设置 `is_end = true`
* 内存管理：使用 `Box` 确保正确的所有权和生命周期

**学习方法论**：

1. 理解字典树的基本原理和适用场景
2. 掌握节点结构设计和内存管理
3. 学会分析不同实现方式的权衡
4. 培养数据结构的抽象设计能力

**算法思维提升**：

* **树形结构思维**：将线性问题转化为层次结构，利用前缀共享
* **前缀优化思维**：利用公共特性减少重复计算

**工程实践建议**：

1. **选择合适实现**：根据字符集特点选择数组或哈希表
2. **考虑内存布局**：数组实现更适合缓存优化
