# Backspace String Compare（栈与双指针优化）

## 题解

---

### 问题描述

给定两个字符串 `s` 和 `t`，判断它们在模拟文本编辑器输入后是否相等。字符 `#` 表示退格键，会删除前一个字符。

**示例**：

```text
示例1：
输入：s = "ab#c", t = "ad#c"
输出：true
解释：两个字符串都变成 "ac"

示例2：
输入：s = "ab##", t = "c#d#"
输出：true
解释：两个字符串都变成 ""

示例3：
输入：s = "a#c", t = "b"
输出：false
解释：s 变成 "c"，t 变成 "b"
```

**约束条件**：

* 字符串长度：1 ≤ s.length, t.length ≤ 200
* 字符串只包含小写字母和 `#` 字符

**进阶要求**：能否在 O(n) 时间复杂度和 O(1) 空间复杂度下解决？

---

### 思路演变：从栈到双指针优化

#### 1. 栈解法（直观易懂）

使用栈来模拟文本编辑器的输入过程：

```rust
impl Solution {
    pub fn backspace_compare(s: String, t: String) -> bool {
        let builder = |s: String| -> String {
            let mut stack = Vec::new();
            for c in s.chars() {
                if c == '#' {
                    stack.pop();  // 遇到退格键，弹出栈顶元素
                } else {
                    stack.push(c);  // 普通字符，压入栈中
                }
            }
            stack.into_iter().collect()  // 将栈转换为字符串
        };
        builder(s) == builder(t)
    }
}
```

**复杂度分析**：

* 时间复杂度：O(n + m)，其中 n 和 m 分别是两个字符串的长度
* 空间复杂度：O(n + m)，需要两个栈来存储处理后的字符串

#### 2. 字符串构建器优化（当前实现）

使用 `String` 的 `pop()` 和 `push()` 方法直接构建结果：

```rust
impl Solution {
    pub fn backspace_compare(s: String, t: String) -> bool {
        let builder = |s: String| -> String {
            let mut res = String::new();
            for c in s.chars() {
                if c == '#' {
                    res.pop();  // 退格：删除最后一个字符
                } else {
                    res.push(c);  // 普通字符：添加到末尾
                }
            }
            res
        };
        builder(s) == builder(t)
    }
}
```

**复杂度分析**：

* 时间复杂度：O(n + m)
* 空间复杂度：O(n + m)，需要存储处理后的字符串

#### 3. 双指针优化（进阶要求）

从字符串末尾向前遍历，实现 O(1) 空间复杂度：

```rust
impl Solution {
    pub fn backspace_compare(s: String, t: String) -> bool {
        let (mut i, mut j) = (s.len(), t.len());
        let (s_chars, t_chars) = (s.as_bytes(), t.as_bytes());
        // 闭包：根据当前索引返回下一个有效字符索引
        let mut next_valid_index = |bytes: &[u8], mut k: usize| -> usize {
            let mut skip = 0;
            while k > 0 {
                if bytes[k - 1] == b'#' {
                    skip += 1;
                    k -= 1;
                } else if skip > 0 {
                    skip -= 1;
                    k -= 1;
                } else {
                    break;
                }
            }
            k
        };
        loop {
            i = next_valid_index(s_chars, i);
            j = next_valid_index(t_chars, j);

            if i > 0 && j > 0 {
                if s_chars[i - 1] != t_chars[j - 1] {
                    return false;
                }
            } else {
                // 排除两个字符不相等
                // 只有两个字符数都为0，才返回真
                return !(i > 0 || j > 0);
            }
            i -= 1;
            j -= 1;
        }
    }
}
```

**复杂度分析**：

* 时间复杂度：O(n + m)
* 空间复杂度：O(1)，只使用常数级别的额外空间

---

### 代码解析

#### 当前实现（字符串构建器）

```rust
let builder = |s: String| -> String {
    let mut res = String::new();
    for c in s.chars() {
        if c == '#' {
            res.pop();      // 退格操作
        } else {
            res.push(c);    // 添加字符
        }
    }
    res
};
```

**执行逻辑**：

1. 创建空字符串 `res` 作为结果容器
2. 遍历输入字符串的每个字符：
   * 遇到 `#`：执行 `res.pop()` 删除最后一个字符
   * 遇到普通字符：执行 `res.push(c)` 添加字符
3. 返回处理后的字符串

**关键特性**：

* 利用 `String` 的 `pop()` 方法实现退格功能
* 闭包封装处理逻辑，代码简洁清晰
* 支持 Unicode 字符处理（使用 `chars()` 迭代器）

#### 双指针优化实现解析

**核心思想**：从后向前遍历，跳过被退格删除的字符

```rust
// 处理退格逻辑
while i >= 0 {
    if s_chars[i as usize] == b'#' {
        skip_s += 1;    // 记录需要跳过的字符数
        i -= 1;
    } else if skip_s > 0 {
        skip_s -= 1;    // 跳过被删除的字符
        i -= 1;
    } else {
        break;          // 找到有效字符
    }
}
```

**算法步骤**：

1. 初始化指针到字符串末尾
2. 分别处理两个字符串的退格：
   * 遇到 `#`：增加跳过计数
   * 遇到普通字符且跳过计数 > 0：减少跳过计数，继续向前
   * 遇到普通字符且跳过计数 = 0：找到有效字符
3. 比较两个有效字符是否相等
4. 移动指针继续处理

---

### 算法对比

| 方法 | 时间复杂度 | 空间复杂度 | 实现难度 | 适用场景 |
|------|------------|------------|----------|----------|
| 栈解法 | O(n + m) | O(n + m) | 简单 | 初学者理解 |
| 字符串构建器 | O(n + m) | O(n + m) | 简单 | 代码简洁 |
| 双指针 | O(n + m) | O(1) | 中等 | 空间优化要求 |

---

### 扩展思考

#### 相关题目

| 题号 | 名称 | 难度 | 核心技巧 |
|------|------|------|----------|
| 1047 | Remove All Adjacent Duplicates In String | 简单 | 栈处理相邻重复 |
| 1209 | Remove All Adjacent Duplicates in String II | 中等 | 栈 + 计数 |
| 1544 | Make The String Great | 简单 | 栈处理大小写相邻 |
| 2390 | Removing Stars From a String | 中等 | 类似退格处理 |

#### 实际应用场景

1. **文本编辑器**：实现撤销操作和退格功能
2. **命令行历史**：处理包含退格键的命令记录
3. **数据清洗**：处理包含删除标记的文本数据
4. **用户输入验证**：比较经过编辑的输入内容

---

## 小结

**重点关注**：

| 知识点 | 重要性 | 学习建议 |
|--------|--------|----------|
| 栈数据结构应用 | ⭐⭐⭐⭐⭐ | 理解 LIFO 特性与退格操作的匹配 |
| 字符串操作优化 | ⭐⭐⭐⭐ | 掌握 Rust 字符串的高效处理方法 |
| 双指针技巧 | ⭐⭐⭐⭐ | 学习逆向遍历和跳过逻辑 |
| 空间复杂度优化 | ⭐⭐⭐ | 理解 O(1) 空间算法的设计思路 |

**Rust 特色实现**：

* 使用闭包封装处理逻辑，提高代码复用性
* `String::pop()` 和 `push()` 方法的合理运用
* 字符迭代器 `chars()` 的 Unicode 安全处理
* 测试驱动的开发模式验证各种边界情况