# 151. 反转字符串中的单词

## 问题描述

给定一个输入字符串 s，反转其中单词的顺序。单词是由非空格字符组成的序列，单词之间由至少一个空格分隔。返回按单词逆序排列并用单个空格连接的字符串。注意 s 可能包含前导或尾随空格或者单词之间的多个空格，返回的字符串应该只有一个空格分隔单词，不包含任何额外的空格。

### 示例

- **示例 1**：
  - 输入：`s = "the sky is blue"`
  - 输出：`"blue is sky the"`

- **示例 2**：
  - 输入：`s = "  hello world  "`
  - 输出：`"world hello"`
  - 说明：反转后的字符串不应包含前导或尾随空格

- **示例 3**：
  - 输入：`s = "a good   example"`
  - 输出：`"example good a"`
  - 说明：需要将两个单词间的多余空格缩减为一个

### 约束条件

- `1 <= s.length <= 10^4`
- `s` 包含英文字母（大写和小写）、数字和空格 `' '`
- `s` 中至少有一个单词

### 进阶问题

如果字符串在你的语言中是可变的，你能否使用 O(1) 额外空间原地解决？

## 实现思路

### 方法概述

本题提供三种实现方式：使用 `split` + `filter`、使用 `split_whitespace` 迭代器、以及使用双指针从后向前遍历。

### 代码实现

```rust
impl Solution {
    // 方法一：split + filter
    pub fn reverse_words(mut s: String) -> String {
        s.split(' ')
            .rev()
            .filter(|x| !x.is_empty())
            .collect::<Vec<_>>()
            .join(" ")
    }

    // 方法二：split_whitespace（更简洁）
    pub fn reverse_words_with_whitespace(mut s: String) -> String {
        s.split_whitespace().rev().collect::<Vec<_>>().join(" ")
    }

    // 方法三：使用 chars 双指针解题
    pub fn reverse_words_with_point(mut s: String) -> String {
        let mut res: Vec<char> = vec![];
        let s: Vec<char> = s.trim().chars().collect::<Vec<_>>(); // 去掉首尾空格
        let mut res = String::with_capacity(s.len());
        let mut i = s.len() as i32 - 1;
        let mut j = s.len() as i32 - 1;
        while i >= 0 {
            while i >= 0 && s[i as usize] != ' ' {
                i -= 1;
            }
            res.extend(&s[i as usize..j as usize]);
            res.push(' ');
            while i >= 0 && s[i as usize] != ' ' {
                i -= 1;
            }
            j = i + 1;
        }
        res.strip_suffix(' ').unwrap().to_string()
    }
}
```

## 实现分析

### 核心思路

1. **方法一**：按空格分割字符串，反转顺序，过滤空字符串，再用空格连接
2. **方法二**：使用 `split_whitespace()` 自动处理多余空格，更加简洁
3. **方法三**：从后向前遍历，使用双指针定位每个单词的边界

### 代码细节

- `split(' ')` 会保留空字符串，需要 `filter` 过滤
- `split_whitespace()` 自动处理所有空白字符（空格、制表符等）
- 双指针方法需要先 `trim()` 去掉首尾空格

### 性能分析

| 类型 | 复杂度 | 说明 |
|------|--------|------|
| 时间复杂度 | O(n) | 遍历字符串一次 |
| 空间复杂度 | O(n) | 需要存储结果字符串 |

## 测试用例

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_151_1() {
        assert_eq!(
            Solution::reverse_words_with_whitespace("  hello world!  ".to_owned()),
            "world! hello".to_owned()
        );
    }

    #[test]
    fn test_151_2() {
        assert_eq!(
            Solution::reverse_words_with_point("  hello world!  ".to_owned()),
            "world! hello".to_owned()
        );
    }

    #[test]
    fn test_151_3() {
        assert_eq!(
            Solution::reverse_words(" a good   example ".to_owned()),
            "example good a".to_owned()
        );
    }
}
```

## 扩展思考

### 进阶问题解答

要实现 O(1) 额外空间，可以：
1. 先反转整个字符串
2. 再逐个反转每个单词
3. 处理多余空格（需要原地移动字符）

### 其他可能的实现方式

1. **栈方法**：
   - 将单词入栈，再依次出栈
   - 时间 O(n)，空间 O(n)

2. **正则表达式**：
   - 使用正则分割和替换
   - 代码简洁但性能略低

## 总结

1. `split_whitespace()` 是最简洁的 Rust 惯用法
2. 双指针方法适合对空间有严格要求的场景
3. 实际应用中推荐使用标准库方法，代码可读性更好
