# Design Linked List（单链表实现）

## 题解

---

### 问题描述

设计链表的实现。可以选择使用单链表或双链表。单链表的节点应包含两个属性：`val` 和 `next`。`val` 是当前节点的值，`next` 是指向下一个节点的指针/引用。

实现 `MyLinkedList` 类：

* `MyLinkedList()`：初始化链表对象
* `get(index)`：获取链表中第 `index` 个节点的值。如果索引无效，返回 -1
* `addAtHead(val)`：在链表的第一个元素之前添加一个值为 `val` 的节点。插入后，新节点将成为链表的第一个节点
* `addAtTail(val)`：将值为 `val` 的节点追加到链表的最后一个元素
* `addAtIndex(index, val)`：在链表中的第 `index` 个节点之前添加值为 `val` 的节点。如果 `index` 等于链表的长度，则该节点将追加到链表的末尾。如果 `index` 大于链表长度，则该节点将 不会插入 到链表中。
* `deleteAtIndex(index)`：如果索引有效，删除链表中的第 `index` 个节点

**示例**：

```text
输入：
["MyLinkedList", "addAtHead", "addAtTail", "addAtIndex", "get", "deleteAtIndex", "get"]
[[], [1], [3], [1, 2], [1], [1], [1]]

输出：
[null, null, null, null, 2, null, 3]

解释：
MyLinkedList myLinkedList = new MyLinkedList();
myLinkedList.addAtHead(1);      // 链表：1
myLinkedList.addAtTail(3);      // 链表：1->3
myLinkedList.addAtIndex(1, 2);  // 链表：1->2->3
myLinkedList.get(1);            // 返回 2
myLinkedList.deleteAtIndex(1);  // 链表：1->3
myLinkedList.get(1);            // 返回 3
```

**约束条件**：

* 0 ≤ index, val ≤ 1000
* 请不要使用内置的 LinkedList 库
* 最多调用 2000 次 get、addAtHead、addAtTail、addAtIndex 和 deleteAtIndex

---

### 数据结构设计

#### 节点结构（Node）

```rust
#[derive(Debug)]
struct Node {
    val: i32,
    next: Option<Box<Node>>,
}
```

**设计要点**：

* `val`：存储节点的整数值

* `next`：使用 `Option<Box<Node>>` 实现可选的下一个节点
* `Box` 指针：确保堆分配和明确的所有权
* `#[derive(Debug)]`：支持调试输出

#### 链表结构（MyLinkedList）

```rust
#[derive(Debug)]
struct MyLinkedList {
    head: Option<Box<Node>>,
    len: usize,
}
```

**设计要点**：

* `head`：指向链表第一个节点的可选指针
* `len`：维护链表长度，优化索引操作
* 长度缓存：避免每次操作都需要遍历计算长度

---

### 核心算法实现

#### 1. 构造函数

```rust
fn new() -> Self {
    MyLinkedList { head: None, len: 0 }
}
```

**初始化**：空链表，头指针为 `None`，长度为 0

#### 2. 获取节点值（get）

```rust
fn get(&self, index: i32) -> i32 {
    // 快速失败检查
    if index < 0 || index >= self.len as i32 {
        return -1;
    }
    
    let mut p = &self.head;
    let mut i = 0;
    
    // 遍历到目标节点
    while let Some(node) = p {
        if i == index {
            break;
        }
        i += 1;
        p = &node.next;
    }
    
    p.as_ref().unwrap().val
}
```

**算法步骤**：

1. 边界检查：索引是否有效
2. 指针遍历：从头节点开始逐个移动
3. 返回值：找到目标节点的值

**时间复杂度**：O(n)，最坏情况需要遍历整个链表

#### 3. 通用辅助方法（find_pre_and_excute）

```rust
fn find_pre_and_excute(&mut self, index: i32, mut update: impl FnMut(&mut Box<Node>)) {
    // 创建虚拟头节点简化操作
    let mut dummy = Some(Box::new(Node {
        val: 0,
        next: self.head.take(),
    }));
    
    let mut cur = &mut dummy;
    let mut i = -1;
    let mut pre = None;
    
    // 查找前驱节点
    while let Some(node) = cur {
        if i + 1 == index {
            pre = Some(cur.as_mut().unwrap());
            break;
        }
        i += 1;
        cur = &mut cur.as_mut().unwrap().next;
    }
    
    // 执行更新操作
    if let Some(pre) = pre {
        update(pre);
    }
    
    // 恢复头指针
    self.head = dummy.as_mut().unwrap().next.take();
}
```

**设计思想**：

* **虚拟头节点**：统一处理头节点的特殊情况
* **函数式参数**：使用闭包实现通用的节点操作
* **所有权管理**：使用 `take()` 方法安全转移指针所有权

#### 4. 添加操作

```rust
fn add_at_head(&mut self, val: i32) {
    self.add_at_index(0, val);
}

fn add_at_tail(&mut self, val: i32) {
    self.add_at_index(self.len as i32, val);
}

fn add_at_index(&mut self, index: i32, val: i32) {
    if index < 0 || index > self.len as i32 {
        return;
    }
    
    self.find_pre_and_excute(index, |node| {
        node.next = Some(Box::new(Node {
            val,
            next: node.next.take(),
        }));
    });
    
    self.len += 1;
}
```

**插入逻辑**：

1. 找到前驱节点
2. 创建新节点：`val` 为指定值，`next` 为前驱节点的原下一个节点
3. 更新前驱节点的 `next` 指向新节点
4. 增加链表长度

#### 5. 删除操作

```rust
fn delete_at_index(&mut self, index: i32) {
    if index < 0 || index >= self.len as i32 {
        return;
    }
    
    self.find_pre_and_excute(index, |node| {
        node.next = node.next.as_mut().unwrap().next.take();
    });
    
    self.len -= 1;
}
```

**删除逻辑**：

1. 找到前驱节点
2. 将前驱节点的 `next` 指向被删除节点的下一个节点
3. 减少链表长度

---

### 复杂度分析

| 操作 | 时间复杂度 | 空间复杂度 | 说明 |
| ------ | ------------ | ------------ | ------ |
| 构造函数 | O(1) | O(1) | 初始化空链表 |
| get | O(n) | O(1) | 需要遍历到目标节点 |
| addAtHead | O(1) | O(1) | 直接修改头指针 |
| addAtTail | O(n) | O(1) | 需要遍历到尾部 |
| addAtIndex | O(n) | O(1) | 需要遍历到目标位置 |
| deleteAtIndex | O(n) | O(1) | 需要遍历到目标位置 |

**优化策略**：

* **长度缓存**：维护 `len` 字段避免重复计算
* **虚拟头节点**：统一处理边界情况
* **快速失败**：先检查索引有效性

---

### 算法对比：单链表 vs 双链表

#### 单链表实现（当前方案）

**优点**：

* 实现简单，代码清晰
* 内存占用小（每个节点少一个指针）
* 插入删除操作相对简单

**缺点**：

* 无法反向遍历
* 删除节点需要找到前驱节点
* 某些操作需要遍历整个链表

#### 双链表实现

```rust
struct DoublyNode {
    val: i32,
    prev: Option<Box<DoublyNode>>,
    next: Option<Box<DoublyNode>>,
}
```

**优点**：

* 支持双向遍历
* 删除操作更高效（不需要找前驱）
* 某些操作时间复杂度更低

**缺点**：

* 实现复杂，指针操作容易出错
* 内存占用更大
* 维护成本更高

---

### 扩展思考

#### 相关题目

| 题号 | 名称 | 难度 | 核心技巧 |
| ------ | ------ | ------ | ---------- |
| 203 | Remove Linked List Elements | 简单 | 链表节点删除 |
| 206 | Reverse Linked List | 简单 | 链表反转 |
| 707 | Design Linked List | 中等 | 链表完整实现 |
| 708 | Insert into a Sorted Circular Linked List | 中等 | 循环链表插入 |

#### 实际应用场景

1. **内存管理**：操作系统中的内存分配链表
2. **文件系统**：文件块的链表存储
3. **浏览器历史**：前进后退功能的实现
4. **音乐播放列表**：歌曲的顺序播放
5. **撤销重做功能**：操作历史的链表存储

#### 算法变体

1. **循环链表**：尾节点指向头节点，形成环
2. **双向链表**：支持前向和后向遍历
3. **跳表**：多级索引加速查找
4. **静态链表**：使用数组模拟链表操作

---

### Rust 实现特色

#### 1. 内存安全设计

```rust
next: Option<Box<Node>>
```

* **Box指针**：确保堆分配和明确的所有权
* **Option包装**：优雅处理空指针情况
* **借用检查**：编译时防止内存安全问题

#### 2. 函数式编程风格

```rust
fn find_pre_and_excute(&mut self, index: i32, mut update: impl FnMut(&mut Box<Node>))
```

* **闭包参数**：将操作逻辑抽象为函数参数
* **泛型约束**：使用 `impl FnMut` 指定函数类型
* **代码复用**：统一处理各种修改操作

#### 3. 所有权管理技巧

```rust
self.head.take()  // 转移所有权
node.next.take()  // 安全断开连接
```

* **take()方法**：安全转移 `Option` 内容的所有权
* **临时所有权**：在操作期间临时持有指针
* **恢复所有权**：操作完成后恢复原始状态

---

## 小结

**核心技巧**：

* **虚拟头节点**：统一处理头节点的特殊情况
* **长度缓存**：维护长度信息优化性能
* **函数式抽象**：使用闭包统一操作逻辑

**关键实现细节**：

* 索引边界检查：防止越界访问
* 指针所有权管理：避免内存泄漏
* 节点插入删除：正确的指针更新顺序

**学习方法论**：

1. 理解链表的基本原理和操作
2. 掌握Rust的所有权和借用系统
3. 学会设计通用的辅助方法
4. 培养数据结构的抽象设计能力

**重点关注**：

| 知识点 | 重要性 | 学习建议 |
| -------- | -------- | ---------- |
| 链表基本原理 | ⭐⭐⭐⭐⭐ | 理解节点连接和指针操作 |
| Rust所有权系统 | ⭐⭐⭐⭐ | 掌握Box、Option的使用 |
| 边界条件处理 | ⭐⭐⭐⭐ | 学会处理空链表和无效索引 |
| 算法复杂度分析 | ⭐⭐⭐ | 理解不同操作的时间成本 |

**工程实践建议**：

1. **选择合适实现**：根据需求选择单链表或双链表
2. **考虑性能需求**：评估操作频率选择优化策略
3. **设计扩展接口**：考虑支持迭代器、查找等操作
4. **错误处理**：完善的边界检查和错误返回

**算法思维提升**：

* **指针操作思维**：理解内存地址和引用关系
* **递归思维**：链表问题往往有递归解法
* **迭代器思维**：将链表视为序列进行处理
* **抽象思维**：将具体操作抽象为通用模式
