# Minimum Size Subarray Sum（最小长度子数组和）

## 题解

---

### 问题描述

**LeetCode 209** - 给定一个正整数数组 `nums` 和一个正整数 `target`，返回和大于等于 `target` 的最小子数组的长度。如果不存在这样的子数组，返回 0。

**示例 1：**

```text
输入：target = 7, nums = [2,3,1,2,4,3]
输出：2
解释：子数组 [4,3] 的长度最小，满足和 ≥ 7。
```

**示例 2：**

```text
输入：target = 4, nums = [1,4,4]
输出：1
解释：子数组 [4] 的长度为 1，满足和 ≥ 4。
```

**示例 3：**

```text
输入：target = 11, nums = [1,1,1,1,1,1,1,1]
输出：0
解释：所有子数组的和都小于 11。
```

**约束条件：**

- `1 <= target <= 10^9`
- `1 <= nums.length <= 10^5`
- `1 <= nums[i] <= 10^4`

---

## 算法思路分析

### 核心思想

这是一个典型的**滑动窗口**问题。由于数组元素都是正数，当窗口扩大时，窗口和单调递增；当窗口缩小时，窗口和单调递减。这个性质使得我们可以使用双指针技术来高效a解决问题。

### 解题策略演变

#### 1. 暴力解法（不推荐）

```rust
// 时间复杂度 O(n²)，空间复杂度 O(1)
// 遍历所有可能的子数组，计算和并比较长度
pub fn min_sub_array_len_brute(target: i32, nums: Vec<i32>) -> i32 {
    let n = nums.len();
    let mut min_len = n + 1; // 初始化为不可能的大值
    
    for i in 0..n {
        let mut sum = 0;
        for j in i..n {
            sum += nums[j];
            if sum >= target {
                min_len = min_len.min(j - i + 1);
                break; // 找到满足条件的子数组，跳出内层循环
            }
        }
    }
    
    if min_len <= n { min_len as i32 } else { 0 }
}
```

#### 2. 滑动窗口优化解法（推荐）

**算法思想：**

- 使用两个指针 `left` 和 `right` 表示窗口的左右边界
- 右指针向右移动，扩大窗口，增加窗口和
- 当窗口和 ≥ target 时，记录当前窗口长度
- 左指针向右移动，缩小窗口，减少窗口和
- 持续这个过程直到遍历完整个数组

- 核心：避免了重复计算同一区间的内容，通过增量更新实现线性时间复杂度。相邻区间间的关系是「增一删一」，可以用前一个结果快速得到下一个。
- 更新左边窗口可以理解为固定右端点，右指针向右移动是更新右端点。
- 左边满足条件后减少1位，只是加上右边最后求出来的长度也不会比当前结果小

```rust
impl Solution {
    pub fn min_sub_array_len(target: i32, nums: Vec<i32>) -> i32 {
        let n = nums.len();
        let mut ans = n + 1;  // 初始化为不可能的大值
        let mut sum = 0;       // 当前窗口的和
        let mut left = 0;      // 窗口左边界
        
        for (right, &x) in nums.iter().enumerate() {
            sum += x;  // 扩大窗口，加入右边界元素
            
            // 当窗口和满足条件时，尝试缩小窗口
            while sum >= target {
                ans = ans.min(right - left + 1);  // 更新最小长度
                sum -= nums[left];               // 缩小窗口，移除左边界元素
                left += 1;                       // 左边界右移
            }
        }
        
        if ans <= n { ans as i32 } else { 0 }  // 返回结果
    }
}
```

**代码解析：**

| 变量 | 含义 | 作用 |
|------|------|------|
| `n` | 数组长度 | 用于边界判断 |
| `ans` | 最小长度 | 存储当前找到的最小满足条件的子数组长度 |
| `sum` | 窗口和 | 当前窗口内所有元素的和 |
| `left` | 窗口左边界 | 指向当前窗口的起始位置 |
| `right` | 窗口右边界 | 指向当前窗口的结束位置 |

**执行流程：**

1. 初始化变量，`ans` 设为 `n+1`（表示初始无解）
2. 右指针 `right` 从 0 开始向右移动
3. 每次移动右指针，将对应元素加入窗口和 `sum`
4. 当 `sum ≥ target` 时：
   - 更新最小长度 `ans = min(ans, right - left + 1)`
   - 移动左指针缩小窗口，直到 `sum < target`
5. 遍历完成后，返回有效的最小长度或 0

---

## 算法对比分析

### 实现方法比较

| 特性 | 暴力解法 | 滑动窗口优化 |
|------|----------|------------|
| **时间复杂度** | O(n²) | **O(n)** |
| **空间复杂度** | O(1) | O(1) |
| **代码简洁性** | ⭐⭐ | **⭐⭐⭐⭐⭐** |
| **性能效率** | ⭐ | **⭐⭐⭐⭐⭐** |
| **可读性** | ⭐⭐ | **⭐⭐⭐⭐** |
| **适用场景** | 小规模数据 | 大规模数据 |

### 关键优化点

1. **单调性利用**：正数数组的窗口和具有单调性
2. **滑动窗口技术**：避免重复计算子数组和

避免了重复计算同一区间的内容，通过增量更新实现线性时间复杂度。相邻区间间的关系是「增一删一」，可以用前一个结果快速得到下一个。为什么？
3. **双指针移动**：左右指针都只向前移动，不会回溯
4. **在线算法**：可以处理流式数据

---

## 复杂度分析

### 时间复杂度

- **最佳情况**：O(n) - 数组开头就有满足条件的子数组
- **最坏情况**：O(n) - 需要遍历整个数组
- **平均情况**：O(n) - 每个元素最多被访问两次

### 空间复杂度

- O(1) - 只使用了常数额外空

## 参考

**参考资料：**

- [LeetCode 209 官方题解](https://leetcode.com/problems/minimum-size-subarray-sum/solution/)
- 《算法导论》- 分治策略与滑动窗口技术
- 《编程珠玑》- 算法优化与性能分析
