# 两两交换链表中的节点（递归实现）

---

### 问题描述

给定一个单链表，将链表中的节点两两交换，并返回交换后的链表。要求**不修改节点值，只能改变节点指针**。

示例：

```text
输入：1->2->3->4
输出：2->1->4->3
```

---

### 解题思路（递归）

1. **递归终止条件**

   * 如果当前节点为 `None` 或只有一个节点 (`n.next == None`)，直接返回该节点，不需要交换。
2. **递归交换每对节点**

   * 对当前节点 `n` 和下一节点 `m`：

     1. 暂存下一轮待处理的链表：`n.next = Self::swap_pairs(m.next)`

        * 递归处理后续链表并连接到 `n`。
     2. 将 `m.next` 指向 `n`，完成当前节点对的交换。
     3. 返回 `m` 作为新的头节点。
3. **递归特点**

   * 每次处理一对节点，递归处理剩余链表。
   * 代码简洁，易读，但由于递归调用栈，空间复杂度为 O(n)。

---

### Rust 实现

```rust
impl Solution {
    pub fn swap_pairs(head: Option<Box<ListNode>>) -> Option<Box<ListNode>> {
        head.and_then(|mut n| {
            match n.next {
                None => Some(n),
                Some(mut m) => {
                    // 递归交换剩余链表
                    n.next = Self::swap_pairs(m.next);
                    // 当前节点对交换
                    m.next = Some(n);
                    Some(m)
                }
            }
        })
    }
}
```

**解释**：

* `and_then`：解包 `Option` 并执行闭包。
* `mut n` / `mut m`：允许修改节点指针。
* 递归实现将链表尾部逐步返回，完成链表重组。

---

### 复杂度分析

* **时间复杂度**：O(n)，每个节点访问一次。
* **空间复杂度**：O(n)，递归栈深度为链表长度的一半。

---

## 小结

**核心技巧**：

* 利用 Rust `Option` 的 `and_then` 简化链表递归操作。
* 递归实现直观，适合链表题快速解法。
* 递归和迭代各有优势：

  * 递归简洁，易读，但栈空间 O(n)；
  * 迭代安全，不占额外栈空间，适合面试强调空间复杂度题目。

**学习方法论**：

1. 熟练掌握 `Option` 的函数式操作 (`map` / `and_then`)。
2. 理解递归链表处理的思想：处理当前节点 + 递归处理剩余节点。
3. 对比迭代与递归，理解不同实现对空间和性能的影响。

**延伸练习**：

* LeetCode 25. K 个一组翻转链表
* LeetCode 206. 反转链表
* LeetCode 83. 删除排序链表中的重复元素

**重点关注**：

* Rust 中 `Option` 与闭包结合的递归处理技巧。
* 链表节点所有权与可变借用管理。
* 递归与迭代实现链表操作的空间与时间权衡。
