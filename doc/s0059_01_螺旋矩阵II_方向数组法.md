# Spiral Matrix II（方向数组法）

## 题解

---

### 问题描述

给定一个正整数 `n`，生成一个 `n × n` 的矩阵，其中元素按螺旋顺序从 1 到 n² 填充。

**示例**：

```text
输入：n = 3
输出：[[1,2,3],
       [8,9,4],
       [7,6,5]]

输入：n = 1
输出：[[1]]
```

**约束条件**：

* 1 ≤ n ≤ 20

**可视化示例**（n=3）：

---

### 思路演变：从边界模拟到方向数组法

#### 1. 边界模拟法（直观但复杂）

通过维护四个边界变量来模拟螺旋填充：

```rust

impl Solution {
    //不需要判断是否越界，因为越界之后(left..=right)不会产生任何元素
    // RangeInclusive 内部有 start 和 end，next() 会先判断是否越界
    // 当 start > end 时，迭代器立即结束，不会 panic
    pub fn generate_matrix(n: i32) -> Vec<Vec<i32>> {
        let n = n as usize;
        let mut ans = vec![vec![0;n as _];n as _];
        let (mut left, mut right, mut top, mut bottom) = (0i32, (n - 1) as i32, 0i32, (n - 1) as i32);
        let mut num = 1;
        while left<=right && top<=bottom{
            for col in left..=right{
                ans[top as usize][col as usize] = num;
                num +=1;
            }

            top +=1;
            for row in top..=bottom{
                ans[row as usize][right as usize] = num;
                num +=1;
            }
            right -=1;
 
            for col in (left..=right).rev(){
                ans[bottom as usize][col as usize] = num;
                num +=1;
            }
            bottom -= 1;
           

            for row in (top..=bottom).rev(){
                ans[row as usize][left as usize] = num;
                num +=1;
            }
            left +=1;
        }
        ans
    }
}

```

**复杂度分析**：

* 时间复杂度：O(n²)，需要填充 n² 个元素
* 空间复杂度：O(n²)，存储结果矩阵

#### 2. 方向数组法（当前实现 - 更优雅）

使用方向数组和智能转向逻辑：

```rust
const DIRS: [(i32, i32); 4] = [(0, 1), (1, 0), (0, -1), (-1, 0)]; // 右下左上

impl Solution {
    pub fn generate_matrix(n: i32) -> Vec<Vec<i32>> {
        let mut ans = vec![vec![0; n as usize]; n as usize];
        let (mut x, mut y, mut di) = (0, 0, 0); // 当前位置和方向索引
        
        for val in 1..=n * n {
            ans[x as usize][y as usize] = val;
            
            // 计算下一步位置
            let next_x = x + DIRS[di].0;
            let next_y = y + DIRS[di].1;
            
            // 检查是否需要转向：越界或已访问
            if next_x < 0 || next_y < 0 || next_x >= n || next_y >= n 
                || ans[next_x as usize][next_y as usize] != 0 {
                di = (di + 1) % 4; // 右转90度
            }
            
            // 移动一步
            x += DIRS[di].0;
            y += DIRS[di].1;
        }
        ans
    }
}
```

**复杂度分析**：

* 时间复杂度：O(n²)
* 空间复杂度：O(n²)

---

### 代码解析

#### 方向数组定义

```rust
const DIRS: [(i32, i32); 4] = [(0, 1), (1, 0), (0, -1), (-1, 0)]; // 右下左上
```

| 方向索引 | 方向向量 | 移动方向 |
|----------|----------|----------|
| 0 | (0, 1) | 向右移动 |
| 1 | (1, 0) | 向下移动 |
| 2 | (0, -1) | 向左移动 |
| 3 | (-1, 0) | 向上移动 |

#### 核心算法逻辑

```rust
for val in 1..=n * n {
    // 1. 填充当前单元格
    ans[x as usize][y as usize] = val;
    
    // 2. 计算下一步位置
    let next_x = x + DIRS[di].0;
    let next_y = y + DIRS[di].1;
    
    // 3. 检查是否需要转向
    if next_x < 0 || next_y < 0 || next_x >= n || next_y >= n 
        || ans[next_x as usize][next_y as usize] != 0 {
        di = (di + 1) % 4; // 顺时针转向
    }
    
    // 4. 移动到下一个位置
    x += DIRS[di].0;
    y += DIRS[di].1;
}
```

**执行流程**（以 n=3 为例）：

1. **初始状态**：x=0, y=0, di=0（向右）
2. **填充顺序**：

(0,0)=1 → (0,1)=2 → (0,2)=3
遇到边界，转向下 → (1,2)=4 → (2,2)=5
遇到边界，转向左 → (2,1)=6 → (2,0)=7
遇到边界，转向上 → (1,0)=8
遇到已访问，转向右 → (1,1)=9

#### 转向条件分析

转向发生在以下情况：

1. **越界检查**：`next_x < 0 || next_y < 0 || next_x >= n || next_y >= n`
2. **已访问检查**：`ans[next_x as usize][next_y as usize] != 0`

**转向逻辑**：`di = (di + 1) % 4` 实现顺时针90度转向

---

### 复杂度分析

| 操作 | 时间复杂度 | 空间复杂度 |
|------|------------|------------|
| 矩阵初始化 | O(n²) | O(n²) |
| 螺旋填充 | O(n²) | O(1) 额外空间 |
| 总计 | O(n²) | O(n²) |

**优化空间**：由于必须存储 n² 个元素，空间复杂度无法优化。

---

### 扩展思考

#### 相关题目

| 题号 | 名称 | 难度 | 核心技巧 |
|------|------|------|----------|
| 54 | Spiral Matrix | 中等 | 螺旋遍历（输入→输出） |
| 885 | Spiral Matrix III | 中等 | 螺旋扩展遍历 |
| 2326 | Spiral Matrix IV | 中等 | 链表+螺旋矩阵 |

---

## 小结

**核心技巧**：

* **方向数组**：统一处理四个移动方向
* **智能转向**：遇到边界或已访问单元格时自动转向
* **模运算**：`(di + 1) % 4` 实现循环转向

**Rust 实现特色**：

* 使用 `const` 定义编译时常量方向数组
* 类型安全的索引处理（i32 ↔ usize）
* 简洁的迭代器模式 `1..=n*n`
* 迭代器模式自动排除非法索引
