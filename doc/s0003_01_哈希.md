# 3. Longest Substring Without Repeating Characters (无重复字符的最长子串)

## 问题描述

给定一个字符串 `s`，请你找出其中不含有重复字符的 **最长子串** 的长度。

### 示例

- **示例 1**：
  - 输入：`s = "abcabcbb"`
  - 输出：`3`
  - 解释：答案是 `"abc"`，长度为 3。注意 `"bca"` 和 `"cab"` 也是正确答案。

- **示例 2**：
  - 输入：`s = "bbbbb"`
  - 输出：`1`
  - 解释：答案是 `"b"`，长度为 1。

- **示例 3**：
  - 输入：`s = "pwwkew"`
  - 输出：`3`
  - 解释：答案是 `"wke"`，长度为 3。注意，答案必须是一个子串，`"pwke"` 是一个子序列而不是子串。

### 约束条件

- `0 <= s.length <= 5 * 10^4`
- `s` 由英文字母、数字、符号和空格组成

## 实现思路

无重复字符的最长子串问题可以使用滑动窗口技术高效解决。滑动窗口是一种在数组或字符串上移动的子数组或子字符串，通过维护窗口的左边界和右边界来找到满足条件的子串。

### 实现方式概述

1. **HashSet 实现**：
   - 使用 HashSet 记录窗口内的字符
   - 右指针向右移动，如果遇到重复字符，左指针向右移动直到窗口内不再有重复字符
   - 记录窗口的最大长度

2. **数组实现**：
   - 使用数组记录字符是否在窗口内出现过
   - 由于字符的 ASCII 值范围有限，可以使用固定大小的数组代替 HashSet
   - 同样使用左右指针维护窗口，记录最大长度

3. **HashMap 优化实现**：
   - 使用 HashMap 记录字符最后出现的位置
   - 当遇到重复字符时，直接将左指针跳转到该字符最后出现位置的下一个位置
   - 避免了逐步移动左指针的开销

4. **字节优化实现**：
   - 使用数组记录字符最近出现的位置
   - 与 HashMap 优化实现类似，但使用数组代替 HashMap 以提高效率
   - 适用于已知字符集的情况（如 ASCII 字符集）

## 实现代码

### HashSet 实现

```rust
impl Solution {
    pub fn length_of_longest_substring(s: String) -> i32 {
        let bytes = s.as_bytes();
        let mut cnt = std::collections::HashSet::new();
        let mut ans = 0;
        let mut l = 0;
        
        for (r, &char) in bytes.iter().enumerate() {
            // 如果字符已存在于窗口中，移动左指针直到窗口中不再包含该字符
            while cnt.contains(&char) {
                cnt.remove(&bytes[l]);
                l += 1;
            }
            // 将当前字符添加到窗口
            cnt.insert(char);
            // 更新最大窗口长度
            ans = ans.max(r - l + 1);
        }
        
        ans as i32
    }
}
```

### 数组实现

```rust
impl Solution {
    pub fn length_of_longest_substring2(s: String) -> i32 {
        let s = s.as_bytes();
        let mut ans = 0;
        let mut l = 0;
        // 使用数组代替HashSet，这里为了效率用的数组
        let mut cnt = [false; 128];
        
        for (r, &c) in s.iter().enumerate() {
            let c = c as usize;
            // 如果窗口内已经包含 c，那么再加入一个 c 会导致窗口内有重复元素
            // 所以要在加入 c 之前，先移出窗口内的 c
            while cnt[c] {
                // 窗口内有 c
                cnt[s[l] as usize] = false;
                l += 1; // 缩小窗口
            }
            cnt[c] = true; // 加入 c
            ans = ans.max(r - l + 1); // 更新窗口长度最大值
        }
        
        ans as _
    }
}
```

### HashMap 优化实现

```rust
impl Solution {
    pub fn length_of_longest_substring3(s: String) -> i32 {
        let bytes = s.as_bytes();
        let mut cnt = std::collections::HashMap::new();
        let mut ans = 0;
        let mut l = 0;
        
        for (r, &char) in bytes.iter().enumerate() {
            // 如果字符已存在，直接将左指针跳转到该字符最后出现位置的下一个位置
            if let Some(&i) = cnt.get(&char) {
                l = l.max(i + 1);
            }
            // 更新字符最后出现的位置
            cnt.insert(char, r);
            // 更新最大窗口长度
            ans = ans.max(r - l + 1);
        }
        
        ans as i32
    }
}
```

### 字节优化实现

```rust
impl Solution {
    pub fn length_of_longest_substring_byte_opt(s: String) -> i32 {
        let bytes = s.as_bytes();
        // 使用数组记录ASCII字符最近出现的位置，初始值为-1
        let mut last = [-1; 128];
        let mut l = 0i32;
        let mut ans = 0i32;

        for (r, &c) in bytes.iter().enumerate() {
            let idx = c as usize;
            // 如果该字符之前出现过，左指针直接跳转到该字符最后出现位置的下一个位置
            if last[idx] >= l {
                l = last[idx] + 1;
            }
            // 更新字符最近出现的位置
            last[idx] = r as i32;
            // 更新最大窗口长度
            ans = ans.max(r as i32 - l + 1);
        }

        ans
    }
}
```

## 实现分析

### 滑动窗口技术核心

1. **核心思路**：
   - 维护一个滑动窗口，窗口内的字符都是唯一的
   - 右指针向右移动，扩展窗口
   - 当遇到重复字符时，左指针向右移动，缩小窗口，直到窗口内不再有重复字符
   - 记录窗口的最大长度

2. **窗口调整策略**：
   - 基础实现（HashSet和数组）：逐步移动左指针直到窗口内不再包含重复字符
   - 优化实现（HashMap和字节数组）：直接将左指针跳转到重复字符最后出现位置的下一个位置

### 各实现方式分析

| 实现方式 | 数据结构 | 时间复杂度 | 空间复杂度 | 优点 | 缺点 | 适用场景 |
|---------|---------|-----------|-----------|------|------|----------|
| HashSet 实现 | HashSet | O(n) | O(min(m, n)) | 适用于任何字符集，代码简洁 | 哈希表操作有一定的开销 | 字符集较大或未知的情况 |
| 数组实现 | 固定大小数组 | O(n) | O(1) | 效率更高，空间复杂度固定 | 仅适用于已知大小的字符集 | 字符集较小的情况（如 ASCII 字符集） |
| HashMap 优化实现 | HashMap | O(n) | O(min(m, n)) | 左指针跳转，减少移动次数 | 哈希表操作有一定的开销 | 字符集较大或未知的情况，追求更高效率 |
| 字节优化实现 | 固定大小数组 | O(n) | O(1) | 效率最高，左指针直接跳转 | 仅适用于已知大小的字符集 | 字符集较小的情况，追求极致效率 |

其中，n 是字符串的长度，m 是字符集的大小。

### 代码细节分析

1. **字符串处理**：
   - 所有实现都将字符串转换为字节数组（`s.as_bytes()`）以提高访问效率
   - 字节数组允许直接访问每个字符的 ASCII 值

2. **窗口维护**：
   - 左指针 `l` 和右指针 `r` 定义窗口的边界
   - 右指针随循环自动递增，左指针根据情况调整

3. **重复检测**：
   - 基础实现使用集合或数组的存在性检查
   - 优化实现使用位置记录直接判断是否需要调整窗口

4. **长度计算**：
   - 窗口长度为 `r - l + 1`
   - 使用 `max` 函数更新最大长度

## 测试用例

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_1() {
        // 测试示例1
        assert_eq!(
            Solution::length_of_longest_substring("abcabcbb".to_string()),
            3
        );
        // 测试示例2
        assert_eq!(
            Solution::length_of_longest_substring("bbbbb".to_string()),
            1
        );
        // 测试示例3
        assert_eq!(
            Solution::length_of_longest_substring("pwwkew".to_string()),
            3
        );
        // 测试空字符串
        assert_eq!(Solution::length_of_longest_substring("".to_string()), 0);
        // 测试所有字符都不同的情况
        assert_eq!(
            Solution::length_of_longest_substring("abcdefg".to_string()),
            7
        );
        // 测试包含空格和特殊字符的情况
        assert_eq!(
            Solution::length_of_longest_substring("a b c a b c".to_string()),
            3
        );
    }
    
    #[test]
    fn test_2() {
        // 测试数组实现
        assert_eq!(
            Solution::length_of_longest_substring2("abcabcbb".to_string()),
            3
        );
        assert_eq!(
            Solution::length_of_longest_substring2("bbbbb".to_string()),
            1
        );
        assert_eq!(
            Solution::length_of_longest_substring2("pwwkew".to_string()),
            3
        );
    }
    
    #[test]
    fn test_3() {
        // 测试HashMap优化实现
        assert_eq!(
            Solution::length_of_longest_substring3("abcabcbb".to_string()),
            3
        );
        assert_eq!(
            Solution::length_of_longest_substring3("bbbbb".to_string()),
            1
        );
        assert_eq!(
            Solution::length_of_longest_substring3("pwwkew".to_string()),
            3
        );
    }
}
```

## 扩展思考

### 其他可能的实现方式

1. **排序比较法**：
   - 对字符串的所有子串进行排序，然后检查是否有重复字符
   - 时间复杂度为 O(n^3)，效率较低，不推荐使用

2. **位运算优化**：
   - 对于仅包含小写字母的情况，可以使用位掩码记录字符是否出现
   - 使用一个整数的位来表示每个字母是否出现
   - 空间复杂度可以进一步优化到 O(1)

### 性能优化考虑

1. **字符集优化**：
   - 如果已知输入字符的范围，可以使用更小的数组代替 `[false; 128]`
   - 例如，如果只包含小写字母，可以使用 `[false; 26]` 或 `[0; 26]`

2. **提前终止**：
   - 如果剩余未处理的字符数加上当前窗口长度小于等于最大窗口长度，可以提前终止循环

3. **内存优化**：
   - 对于非常长的字符串，可以考虑使用更高效的内存布局
   - 或者使用原地算法，避免额外的内存分配

### 与其他问题的关联

1. **最小覆盖子串**：
   - 与本题类似，也是使用滑动窗口技术
   - 但需要找到包含所有目标字符的最小子串

2. **至多包含两个不同字符的最长子串**：
   - 是本题的扩展，允许子串中包含最多两个不同的字符

3. **至多包含 K 个不同字符的最长子串**：
   - 是本题的进一步扩展，允许子串中包含最多 K 个不同的字符

## 总结

本问题提供了四种基于滑动窗口技术的高效解决方案，从基础的 HashSet 实现到优化的字节数组实现，逐步提升了算法的效率。

滑动窗口技术是解决字符串子串问题的常用方法，通过维护一个动态窗口，可以在 O(n) 的时间复杂度内找到满足条件的子串。

各实现方式各有优缺点：
- HashSet 实现适用于任何字符集，代码简洁易懂
- 数组实现更高效，适用于已知字符集的情况
- HashMap 优化实现通过直接跳转左指针提高了效率
- 字节优化实现结合了数组的高效访问和左指针跳转的优点，是四种实现中效率最高的

在实际应用中，应根据输入字符的特点和性能要求选择合适的实现方式。对于大多数情况，字节优化实现是最佳选择，因为它提供了极致的效率和固定的空间复杂度。