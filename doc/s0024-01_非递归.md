# 两两交换链表中的节点 (LeetCode 24)

---

### 问题描述

给定一个单链表，将链表中的节点两两交换，并返回交换后的链表。要求**不修改节点值，只能改变节点指针**。

示例：

```text
输入：1->2->3->4
输出：2->1->4->3
```

---

### 解题思路

1. **使用哨兵节点 (dummy node)**

   * 构造一个额外的虚拟头节点，简化链表头部的交换操作，避免头节点特殊处理。
2. **尾指针 tail**

   * `tail` 指向当前已处理链表的最后一个节点，用于拼接新的交换节点。
3. **循环交换每一对节点**
   对于一对节点 `first -> second`：

   1. 暂存下一轮待处理的链表：`head = second.next.take()`。
   2. 交换节点：`second.next = Some(first)`。
   3. 拼接到已处理链表：`tail.next = Some(second)`。
   4. 更新尾节点：`tail = tail.next.as_mut().unwrap().next.as_mut().unwrap()`。
4. **处理链表长度为奇数的情况**

   * 如果最后只剩一个节点，则直接拼接到尾部。

**Rust 技巧**：

* `Option::take()`：转移所有权，避免多重借用。
* `as_mut()`：安全获取内部可变引用。
* `dummy node + tail`：链表拼接的通用方法。

---

### 复杂度分析

* **时间复杂度**：O(n)，每个节点访问一次。
* **空间复杂度**：O(1)，仅使用一个 dummy 节点和尾指针引用，没有额外分配节点。

---

### Rust 实现

```rust
// Definition for singly-linked list.
// #[derive(PartialEq, Eq, Clone, Debug)]
// pub struct ListNode {
//     pub val: i32,
//     pub next: Option<Box<ListNode>>,
// }
//
// impl ListNode {
//     #[inline]
//     fn new(val: i32) -> Self {
//         ListNode { next: None, val }
//     }
// }

impl Solution {
    pub fn swap_pairs(mut head: Option<Box<ListNode>>) -> Option<Box<ListNode>> {
        // 1️⃣ 构造哨兵节点，简化链表操作
        let mut dummy = Box::new(ListNode::new(0));
        // tail 始终指向已处理链表的最后节点
        let mut tail = &mut dummy;

        // 2️⃣ 遍历链表，每次处理一对节点
        while let Some(mut first) = head {
            if let Some(mut second) = first.next.take() {
                // 暂存下一轮待处理的链表
                head = second.next.take();

                // 交换节点
                second.next = Some(first);

                // 拼接到已处理链表
                tail.next = Some(second);

                // 更新尾节点，指向当前已处理链表的最后一个节点
                tail = tail.next.as_mut().unwrap().next.as_mut().unwrap();
            } else {
                // 如果剩余只有一个节点，直接拼接
                tail.next = Some(first);
                break;
            }
        }
        // 返回新的链表头
        dummy.next
    }
}
```

---

## 小结

**核心技巧**：

* 使用 `Option::take()` 转移所有权，避免多重借用冲突。
* 使用 `dummy node + tail` 结构进行链表拼接，提高代码可读性和安全性。
* 循环处理每对节点，轻松扩展到 k-group swap 或递归实现。

**学习方法论**：

1. 熟练掌握 Rust 的所有权与可变借用 (`Option::take()`、`as_mut()`)。
2. 多练习链表题，尤其是头节点、尾节点特殊情况的处理。
3. 尝试从迭代实现扩展到递归实现或 k-group swap。

**延伸练习**：

* LeetCode 25. K 个一组翻转链表
* LeetCode 83. 删除排序链表中的重复元素
* LeetCode 206. 反转链表

**重点关注**：

* Rust 链表操作中的所有权管理
* dummy 节点 + tail 模式的通用链表拼接技巧
* 安全访问可变引用 (`as_mut`) 的底层原理
