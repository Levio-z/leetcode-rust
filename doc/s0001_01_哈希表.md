# Two Sum（哈希表优化）

## 题解

---

### 问题描述

给定一个整数数组 `nums` 和一个目标值 `target`，找出数组中两个数的 **索引**，使得它们的和等于 `target`。要求**尽可能优化时间复杂度**。

示例：

```text
输入：nums = [2,7,11,15], target = 9
输出：[0,1]
```

---

### 思路演变：从暴力解到构造辅助哈希表优化

1. **暴力解法 1：枚举后面元素**

   * 对每个元素 `nums[i]`，遍历其右边所有元素 `nums[j]`，检查 `nums[i] + nums[j] == target`。
   * 查找操作是 O(n)，总时间复杂度 O(n²)。

   ```rust
   impl Solution {
       pub fn two_sum(nums: Vec<i32>, target: i32) -> Vec<i32> {
           for i in 0..nums.len() { // 枚举 i
               for j in i + 1..nums.len() { // 枚举 i 右边的 j
                   if nums[i] + nums[j] == target { // 满足要求
                       return vec![i as i32, j as i32]; // 返回两个数的下标
                   }
               }
           }
           unreachable!() // 题目保证有解
       }
   }
   ```

2. **暴力解法 2：枚举前面元素（在线算法雏形）**

   * 对每个元素 `nums[i]`，遍历它左边的历史元素 `nums[j]`，检查 `nums[i] + nums[j] == target`。
   * 这种方法体现了“只依赖历史状态”的在线思想，为后续哈希表优化提供思路。

   ```rust
   impl Solution {
       pub fn two_sum(nums: Vec<i32>, target: i32) -> Vec<i32> {
           for i in 0..nums.len() {
               for j in 0..i { // 只遍历 i 左边的元素
                   if nums[i] + nums[j] == target {
                       return vec![i as i32, j as i32];
                   }
               }
           }
           unreachable!("保证有解")
       }
   }
   ```

    > ✅ 核心启发：暴力解法 2 中“只看历史元素”思想可以通过哈希表将查找复杂度从 O(n) 降为 O(1)，形成在线算法优化。

3. **哈希表优化（在线算法）**

   * 遍历数组的同时，用哈希表存储已访问的元素。
   * 对每个元素，检查哈希表中是否存在与当前元素互补的值，若存在则立即返回结果。

   ```rust
   use std::collections::HashMap;
   
   impl Solution {
       pub fn two_sum(nums: Vec<i32>, target: i32) -> Vec<i32> {
           let mut idx = HashMap::with_capacity(nums.len());
           for (i, &x) in nums.iter().enumerate() {
               if let Some(&j) = idx.get(&(target - x)) {
                   return vec![i as i32, j as i32];
               }
               idx.insert(x, i);
           }
           vec![]
       }
   }
   ```

---

### 代码解析

| 变量           | 含义                |
| ------------ | ----------------- |
| `idx`        | 哈希表，存储「数值 → 索引」映射 |
| `i`          | 当前元素索引            |
| `x`          | 当前元素值             |
| `target - x` | 当前元素期望匹配的补数       |
| `j`          | 补数在哈希表中对应的索引      |

**执行逻辑**：

1. 遍历每个元素 `(i, x)`。
2. 查询哈希表中是否存在与当前 `x` 互补的值 `target - x`：

   * 若存在，则返回 `[i, j]`。
   * 若不存在，则将 `(x, i)` 加入哈希表以备后续匹配。
3. 整个过程只需一次遍历，查找与插入都是 O(1)。

---

### 复杂度分析

| 类型    | 复杂度              |
| ----- | ---------------- |
| 时间复杂度 | O(n)，只需一次遍历      |
| 空间复杂度 | O(n)，哈希表存储访问过的元素 |

---

## 小结

**核心技巧**：

* 哈希表将查找操作从 O(n) 降为 O(1)。
* 体现了典型的“**空间换时间**”思想。
* 哈希表优化是从暴力解法 2 的“历史元素查找”演化而来的在线算法。

**学习方法论**：

1. 抽象问题核心：**查找 + 配对**。
2. 优先选择支持快速查找的数据结构（哈希表、集合）。
3. 思考能否“在线算法”，减少冗余遍历。

**延伸练习**：

| 题号           | 名称                    | 思维扩展方向      |
| ------------ | --------------------- | ----------- |
| LeetCode 1   | Two Sum               | 哈希表查找基础     |
| LeetCode 167 | Two Sum II            | 双指针优化版本     |
| LeetCode 15  | 3Sum                  | 扩展为三数匹配     |
| LeetCode 560 | Subarray Sum Equals K | 前缀和 + 哈希表进阶 |

**重点关注**：

| 知识点                         | 价值    |
| --------------------------- | ----- |
| 哈希表底层实现原理（哈希函数、冲突解决）        | ⭐⭐⭐⭐  |
| 空间换时间策略                     | ⭐⭐⭐⭐  |
| 在线算法设计思想（Streaming）         | ⭐⭐⭐⭐⭐ |
| Rust 中 `HashMap` 的性能特征与使用惯例 | ⭐⭐⭐⭐  |
