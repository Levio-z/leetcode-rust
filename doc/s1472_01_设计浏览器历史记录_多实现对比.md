# Design Browser History（多实现对比）

## 题解

---

### 问题描述

你有一个单标签页的浏览器，从主页开始，可以访问其他 URL，在历史记录中后退若干步或前进若干步。实现 BrowserHistory 类：

* `BrowserHistory(string homepage)`：用浏览器的 homepage 初始化对象
* `void visit(string url)`：从当前页面访问 url，清除所有前进历史
* `string back(int steps)`：在历史记录中后退 steps 步。如果只能返回 x 步且 steps > x，将只返回 x 步。返回后退后最多 steps 步后的当前 URL
* `string forward(int steps)`：在历史记录中前进 steps 步。如果只能前进 x 步且 steps > x，将只前进 x 步。返回前进后最多 steps 步后的当前 URL

**示例**：

```text
输入：
["BrowserHistory","visit","visit","visit","back","back","forward","visit","forward","back","back"]
[["leetcode.com"],["google.com"],["facebook.com"],["youtube.com"],[1],[1],[1],["linkedin.com"],[2],[2],[7]]

输出：
[null,null,null,null,"facebook.com","google.com","facebook.com",null,"linkedin.com","google.com","leetcode.com"]

解释：
BrowserHistory browserHistory = new BrowserHistory("leetcode.com");
browserHistory.visit("google.com");       // 当前在 "leetcode.com"，访问 "google.com"
browserHistory.visit("facebook.com");     // 当前在 "google.com"，访问 "facebook.com"  
browserHistory.visit("youtube.com");      // 当前在 "facebook.com"，访问 "youtube.com"
browserHistory.back(1);                   // 当前在 "youtube.com"，后退到 "facebook.com"，返回 "facebook.com"
browserHistory.back(1);                   // 当前在 "facebook.com"，后退到 "google.com"，返回 "google.com"
browserHistory.forward(1);                // 当前在 "google.com"，前进到 "facebook.com"，返回 "facebook.com"
browserHistory.visit("linkedin.com");     // 当前在 "facebook.com"，访问 "linkedin.com"
browserHistory.forward(2);                // 当前在 "linkedin.com"，无法前进任何步数，返回 "linkedin.com"
browserHistory.back(2);                   // 当前在 "linkedin.com"，后退两步到 "facebook.com" 再到 "google.com"，返回 "google.com"
browserHistory.back(7);                   // 当前在 "google.com"，只能后退一步到 "leetcode.com"，返回 "leetcode.com"
```

**约束条件**：

* 1 <= homepage.length <= 20
* 1 <= url.length <= 20  
* 1 <= steps <= 100
* homepage 和 url 由 '.' 或小写英文字母组成
* 最多调用 5000 次 visit、back 和 forward

---

### 抽象设计

#### 浏览器历史记录 Trait

```rust
pub trait BrowserHistoryTrait {
    fn new(homepage: String) -> Self where Self: Sized;
    fn visit(&mut self, url: String);
    fn back(&mut self, steps: i32) -> String;
    fn forward(&mut self, steps: i32) -> String;
}
```

**设计思想**：

* **接口抽象**：统一的操作接口，支持多种实现
* **泛型约束**：使用 `where Self: Sized` 确保具体类型
* **可变引用**：操作需要修改内部状态

---

### 实现方案对比

#### 1. 数组实现（ArrayBrowserHistory）

```rust
#[derive(Debug)]
pub struct ArrayBrowserHistory {
    history: Vec<String>,
    cur: i32,
    end: i32,
}
```

**核心思想**：

* 使用向量存储所有访问过的 URL
* 使用 `cur` 指针表示当前位置
* 使用 `end` 指针表示有效历史记录的终点

**操作复杂度**：

* `visit`：O(1) 平均，O(n) 最坏（向量扩容）
* `back`：O(1)
* `forward`：O(1)

**优点**：

* 内存连续访问，缓存友好
* 导航操作非常高效
* 实现简单直观

**缺点**：

* 内存使用可能较高（保留所有历史）
* 向量扩容时有性能开销

#### 2. 双栈实现（StackBrowserHistory）

```rust
#[derive(Debug)]
pub struct StackBrowserHistory {
    back_stack: Vec<String>,
    forward_stack: Vec<String>,
}
```

**核心思想**：

* `back_stack`：存储可以后退的页面
* `forward_stack`：存储可以前进的页面
* 当前页面始终在 `back_stack` 的顶部

**操作复杂度**：

* `visit`：O(k)（k 是前进栈的大小）
* `back`：O(steps)
* `forward`：O(steps)

**优点**：

* 后退前进操作逻辑清晰
* 内存使用相对优化
* 符合浏览器实际工作方式

**缺点**：

* 导航操作需要移动元素
* 访问操作需要清空前进栈

#### 3. 截断数组实现（TruncateArrayBrowserHistory）

```rust
#[derive(Debug)]
pub struct TruncateArrayBrowserHistory {
    urls: Vec<String>,
    curr_index: usize,
}
```

**核心思想**：

* 使用向量存储 URL，访问时截断后续历史
* `curr_index` 表示当前位置
* 访问新 URL 时删除所有前进历史

**操作复杂度**：

* `visit`：O(1) 平均，O(n) 最坏（截断操作）
* `back`：O(1)
* `forward`：O(1)

**优点**：

* 内存使用最优（只保留有效历史）
* 导航操作高效
* 实现简洁

**缺点**：

* 截断操作可能有性能开销
* 丢失前进历史信息

---

### 性能对比分析

#### 内存使用比较

| 实现方案 | 平均内存 | 最坏内存 | 内存效率 |
| --------- | --------- | --------- | --------- |
| 数组实现 | O(n) | O(n) | 低 |
| 双栈实现 | O(n) | O(n) | 中 |
| 截断数组 | O(k) | O(n) | 高 |

注：n 是总访问次数，k 是当前有效历史长度

#### 操作性能比较

| 操作类型 | 数组实现 | 双栈实现 | 截断数组 |
| --------- | --------- | --------- | --------- |
| visit | O(1) | O(k) | O(1) |
| back | O(1) | O(steps) | O(1) |
| forward | O(1) | O(steps) | O(1) |

#### 适用场景推荐

1. **高频导航场景**：推荐数组实现（导航操作 O(1)）
2. **内存敏感场景**：推荐截断数组实现（内存使用最优）
3. **逻辑清晰需求**：推荐双栈实现（符合实际浏览器逻辑）

---

### Rust 实现特色

#### 1. 所有权管理

```rust
// 安全的指针操作
self.history[self.cur as usize].clone()

// 边界安全的索引操作
self.cur = (self.cur - steps).max(0);
```

#### 2. 泛型编程

```rust
// 通用的测试函数
fn test_basic_operations<T: BrowserHistoryTrait>() {
    let mut browser_history = T::new("leetcode.com".to_string());
    // 测试逻辑...
}
```

#### 3. 性能测试框架

```rust
fn performance_test<T: BrowserHistoryTrait + 'static>(impl_name: &str) {
    let start = Instant::now();
    // 性能测试逻辑...
    println!("{} 性能测试完成", impl_name);
}
```

---

### 测试用例设计

#### 基础功能测试

```rust
fn test_basic_operations<T: BrowserHistoryTrait>() {
    let mut browser_history = T::new("leetcode.com".to_string());
    browser_history.visit("google.com".to_string());
    browser_history.visit("facebook.com".to_string());
    browser_history.visit("youtube.com".to_string());
    
    assert_eq!(browser_history.back(1), "facebook.com".to_string());
    assert_eq!(browser_history.back(1), "google.com".to_string());
    // 更多断言...
}
```

#### 边界条件测试

```rust
fn test_edge_cases<T: BrowserHistoryTrait>() {
    let mut browser_history = T::new("homepage.com".to_string());
    
    // 测试边界后退
    assert_eq!(browser_history.back(100), "homepage.com".to_string());
    
    // 测试边界前进  
    assert_eq!(browser_history.forward(100), "homepage.com".to_string());
    
    // 测试连续访问
    for i in 0..10 {
        browser_history.visit(format!("site{}.com", i));
    }
}
```

#### 性能对比测试

```rust
fn compare_performance() {
    performance_test::<ArrayBrowserHistory>("数组实现");
    performance_test::<StackBrowserHistory>("双栈实现");
    performance_test::<TruncateArrayBrowserHistory>("截断数组实现");
}
```

---

### 扩展思考

#### 1. 相关 LeetCode 问题

* **146. LRU Cache**：缓存淘汰策略，类似的历史管理
* **155. Min Stack**：栈的特殊应用
* **716. Max Stack**：最大栈的实现

#### 2. 实际应用场景

* **Web 浏览器**：真实的浏览器历史记录管理
* **文件管理器**：目录导航历史
* **IDE 导航**：代码编辑器的前进后退功能

#### 3. 算法优化方向

* **惰性截断**：延迟截断操作，优化性能
* **内存池**：使用自定义内存分配器优化内存使用
* **并发安全**：添加线程安全支持

---

### 总结

**核心设计模式**：

1. **Trait 抽象**：统一的接口设计，支持多实现
2. **状态管理**：三种不同的状态维护策略
3. **性能权衡**：在不同场景下选择最优实现

**技术亮点**：

1. **泛型测试**：使用 trait 实现通用的测试框架
2. **性能分析**：完整的性能对比和测试方案
3. **Rust 特性**：充分利用 Rust 的类型系统和内存安全

**学习价值**：

1. **设计模式**：学习接口抽象和多种实现的设计思想
2. **性能分析**：掌握算法性能评估和比较的方法
3. **实际问题**：了解浏览器历史记录管理的实际需求