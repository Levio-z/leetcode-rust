# 移除重复元素

## 题解

---

### 问题描述

给你一个 非严格递增排列 的数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。元素的 相对顺序 应该保持 一致 。然后返回 nums 中唯一元素的个数。

考虑 nums 的唯一元素的数量为 k。去重后，返回唯一元素的数量 k。

nums 的前 k 个元素应包含 排序后 的唯一数字。下标 k - 1 之后的剩余元素可以忽略。

示例：

```text
示例 1：

输入：nums = [1,1,2]
输出：2, nums = [1,2,_]
解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。
示例 2：

输入：nums = [0,0,1,1,1,2,2,3,3,4]
输出：5, nums = [0,1,2,3,4,_,_,_,_,_]
解释：函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的元素。
```

### 解题思路

1. **前向覆盖法**

   * 慢指针 `i` 用于记录当前唯一元素的位置。
   * 快指针 `j` 用于遍历数组。

   ```rust
    impl Solution {
        pub fn remove_element(nums: &mut Vec<i32>, val: i32) -> i32 {
            if nums.is_empty() {
                return 0;
            }
            let mut i = 0;
            for j in 0..nums.len() {
                if val != nums[j] {
                    nums[i] = nums[j];
                    i = i + 1;
                }
            }
            nums.truncate(i);
            i as _
        }
    }
   ```

---

✅ 特点

逻辑：将非目标值前移覆盖目标值。

保持原有相对顺序。

fast 遍历所有元素，slow 表示“下一个要写入的位置”。

最后 truncate(slow) 去掉尾部无效部分。

⚙️ 时间与空间

时间：O(n)

空间：O(1)

保序（顺序不变）

---

2.**尾部替换法（快慢指针）**

* 首部指针 `start` 用于遍历元素找到目标值，找到后用尾部值替换，start也是新数组的当前长度。
* 尾部指针 `end` 用于记录当前有效数组长度。

   ```rust
    impl Solution {
        pub fn remove_element(nums: &mut Vec<i32>, val: i32) -> i32 {
            let (mut start,mut end) = (0,nums.len());
            while start < end {
                if nums[start] == val{
                    nums[start] = nums[end-1];
                    end -=1;
                }else{
                    start +=1;
                }
            }
            nums.truncate(end);
            end as i32
        }
    }
   ```

---
⚙️ 核心逻辑

start 从左扫描；

end 表示“当前有效数组尾的下一个位置”；

当 nums[start] == val，直接用尾部值 nums[end - 1] 替换；

然后收缩尾部边界（end -= 1），不递增 start；

否则递增 start。

⚙️ 时间与空间

时间：O(n)

空间：O(1)

不保序（顺序被打乱）

---

## 小结

**核心技巧**：

* 使用双指针技术，一个指针遍历数组，另一个指针记录唯一元素的位置。
* 通过比较当前元素是否是目标值，来判断是否需要保留。
* 最后使用 `truncate` 方法调整数组长度，去除多余元素。

| 算法        | 主体逻辑                                   | 写操作触发条件                        |
| --------- | -------------------------------------- | ------------------------------ |
| **前向覆盖法** | 每读一个非目标值，就写入 `nums[slow] = nums[fast]` | 所有非目标值都会写一次                    |
| **尾部替换法** | 只在遇到目标值时，从尾部拿一个值覆盖                     | 仅当发现 `nums[start] == val` 时写一次 |
