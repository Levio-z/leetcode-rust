# 344. 反转字符串

## 问题描述

编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 `s` 的形式给出。必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。

### 示例

- **示例 1**：
  - 输入：`s = ["h","e","l","l","o"]`
  - 输出：`["o","l","l","e","h"]`

- **示例 2**：
  - 输入：`s = ["H","a","n","n","a","h"]`
  - 输出：`["h","a","n","n","a","H"]`

### 约束条件

- `1 <= s.length <= 10^5`
- `s[i]` 是可打印的 ASCII 字符

## 实现思路

### 方法概述

本题提供多种实现方式：双指针交换、迭代器收集、元组解构、递归、分治法以及直接使用切片的 `reverse()` 方法。

### 代码实现

```rust
impl Solution {
    // 方法一：双指针 + swap
    pub fn reverse_string(s: &mut [char]) {
        let mut i = 0;
        let mut j = s.len() - 1;
        while i < j {
            s.swap(i, j);
            // 相当于手动 let temp = s[i]; s[i] = s[j]; s[j] = temp;
            // 切片上更好的方法 s.reverse();
            i += 1;
            j -= 1;
        }
    }

    /// 收集器,所有权转移,迭代器风格
    pub fn reverse_string1(mut s: &mut Vec<char>) {
        *s = s.iter().rev().copied().collect::<Vec<_>>();
    }

    /// 元组解构
    pub fn reverse_string2(mut s: &mut [char]) {
        let mut i = 0;
        let mut j = s.len() - 1;
        while i < j {
            (s[i], s[j]) = (s[j], s[i]);
            i += 1;
            j -= 1;
        }
    }

    /// 递归
    pub fn reverse_string3(mut s: &mut [char]) {
        Self::reverse_recursive(s, 0, s.len() - 1);
    }

    fn reverse_recursive(s: &mut [char], left: usize, right: usize) {
        if left >= right {
            return;
        }
        s.swap(left, right);
        Self::reverse_recursive(s, left + 1, right - 1);
    }

    /// 分而治之
    pub fn reverse_string4(mut s: &mut [char]) {
        if s.len() <= 1 {
            return;
        }
        // mid 始终是左半部分的长度
        // mid - 1 始终是左半部分的最后一个元素
        let mid = s.len() / 2;
        let (left, right) = s.split_at_mut(mid);
        // 如果任意一个返回 None，zip 就停止迭代
        for (l, r) in left.iter_mut().zip(right.iter_mut().rev()) {
            core::mem::swap(l, r);
        }
    }

    /// str 上的一些方法（unsafe）
    fn reverse_string_ascii(s: &mut str) {
        unsafe {
            let bytes = s.as_bytes_mut();
            bytes.reverse();
        }
    }
}
```

## 实现分析

### 核心思路

1. **双指针法**：使用两个指针分别从头尾向中间移动，交换元素
2. **迭代器法**：反向迭代并收集到新 Vec，再赋值回原数组
3. **元组解构**：利用 Rust 的元组解构语法同时交换两个值
4. **递归法**：递归地交换首尾元素
5. **分治法**：将数组分成两半，用 zip 配对交换

### 代码细节

- `s.swap(i, j)` 是切片上交换元素的惯用方法
- 元组解构 `(s[i], s[j]) = (s[j], s[i])` 更加直观
- 递归方法在大数组上可能导致栈溢出
- `split_at_mut` 可以同时获取可变的左右两半

### 性能分析

| 方法 | 时间复杂度 | 空间复杂度 | 说明 |
|------|--------|--------|------|
| 双指针 | O(n) | O(1) | 最优解 |
| 迭代器 | O(n) | O(n) | 需要额外空间 |
| 递归 | O(n) | O(n) | 栈空间 |
| 分治 | O(n) | O(1) | 原地操作 |

## 测试用例

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_344() {
        let mut s = vec!['h', 'e', 'l', 'l', 'o'];
        Solution::reverse_string4(&mut s);
        assert_eq!(s, vec!['o', 'l', 'l', 'e', 'h']);
    }
}
```

## 扩展思考

### 其他可能的实现方式

1. **直接使用标准库**：
   - `s.reverse()` 一行搞定
   - 推荐在生产代码中使用

2. **位运算 XOR 交换**：
   - 不需要临时变量
   - 但可读性较差

## 总结

1. 双指针 + `swap` 是经典的原地反转方法
2. Rust 的 `slice.reverse()` 是最简洁的选择
3. 递归方法适合教学，但生产中应避免（栈溢出风险）
4. 分治法展示了 `split_at_mut` 的妙用
