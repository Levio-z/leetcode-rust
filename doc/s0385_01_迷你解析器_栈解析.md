# Mini Parser（栈解析实现）

## 题解

---

### 问题描述

给定一个字符串 `s` 表示嵌套列表的序列化，实现一个解析器将其反序列化并返回反序列化的 `NestedInteger`。

每个元素要么是一个整数，要么是一个列表，其元素也可以是整数或其他列表。

**示例 1**：

```text
输入：s = "324"
输出：324
解释：应该返回一个包含单个整数 324 的 NestedInteger 对象
```

**示例 2**：

```text
输入：s = "[123,[456,[789]]]"
输出：[123,[456,[789]]]
解释：返回一个包含嵌套列表的 NestedInteger 对象，该列表有 2 个元素：
1. 包含值 123 的整数
2. 包含两个元素的嵌套列表：
   i. 包含值 456 的整数
   ii. 包含一个元素的嵌套列表：
      a. 包含值 789 的整数
```

**约束条件**：

* 1 <= s.length <= 5 * 10^4
* s 由数字、方括号 "[]"、负号 '-' 和逗号 ',' 组成
* s 是有效的 NestedInteger 的序列化
* 输入中的所有值都在范围 [-10^6, 10^6] 内

---

### 数据结构设计

#### 嵌套整数枚举（NestedInteger）

```rust
#[derive(Debug, PartialEq, Eq)]
pub enum NestedInteger {
    Int(i32),
    List(Vec<NestedInteger>),
}
```

**设计要点**：

* **枚举类型**：使用 Rust 的枚举表示两种可能的值类型
* `Int(i32)`：表示单个整数
* `List(Vec<NestedInteger>)`：表示嵌套列表，支持递归定义
* `#[derive(Debug, PartialEq, Eq)]`：支持调试输出和相等比较

#### 解析器结构（Parser）

```rust
struct Parser {
    stack: Vec<NestedInteger>,
    num: i32,
    sign: i32,
    in_number: bool,
}
```

**状态管理**：

* `stack`：解析栈，用于构建嵌套结构
* `num`：当前正在解析的数字
* `sign`：数字的符号（1 或 -1）
* `in_number`：标记是否正在解析数字

---

### 核心算法实现

#### 1. 主解析函数（deserialize）

```rust
pub fn deserialize(s: String) -> NestedInteger {
    // 快速路径：如果字符串不以 '[' 开头，直接解析为整数
    if !s.starts_with('[') {
        return NestedInteger::Int(s.parse().unwrap());
    }

    let mut p = Parser {
        stack: Vec::new(),
        num: 0,
        sign: 1,
        in_number: false,
    };

    // 逐个字符处理
    for ch in s.bytes() {
        match ch {
            b'-' => p.sign = -1,
            b'0'..=b'9' => {
                p.num = p.num * 10 + (ch - b'0') as i32;
                p.in_number = true;
            }
            b'[' => {
                // 开始新的列表
                p.stack.push(NestedInteger::List(vec![]));
            }
            b',' | b']' => {
                // 处理数字结束或列表结束
                p.flush_number();
                if ch == b']' {
                    p.close_list();
                }
            }
            _ => {}
        }
    }

    p.stack.pop().unwrap()
}
```

**解析流程**：

1. **快速检查**：如果输入是纯数字，直接解析
2. **初始化解析器**：创建解析器状态
3. **字符遍历**：根据字符类型执行不同操作
4. **返回结果**：栈顶元素即为最终结果

#### 2. 数字处理函数（flush_number）

```rust
fn flush_number(&mut self) {
    if self.in_number {
        if let Some(NestedInteger::List(top)) = self.stack.last_mut() {
            top.push(NestedInteger::Int(self.sign * self.num));
        }
        // 重置数字状态
        self.num = 0;
        self.sign = 1;
        self.in_number = false;
    }
}
```

**功能**：

* 将当前解析的数字推入栈顶列表
* 重置数字解析状态
* 处理符号和数值计算

#### 3. 列表闭合函数（close_list）

```rust
fn close_list(&mut self) {
    if self.stack.len() > 1 {
        let ni = self.stack.pop().unwrap();
        if let Some(NestedInteger::List(top)) = self.stack.last_mut() {
            top.push(ni);
        }
    }
}
```

**嵌套处理**：

* 将当前列表推入父级列表
* 维护正确的嵌套层级关系
* 处理栈的层级管理

---

### 算法复杂度分析

#### 时间复杂度

* **O(n)**：需要遍历输入字符串的每个字符一次
* 每个字符的处理都是常数时间操作

#### 空间复杂度

* **O(d)**：其中 d 是最大嵌套深度
* 栈的深度与嵌套层级相关
* 最坏情况下为 O(n)，当输入是深度嵌套时

---

### 算法特色

#### 1. 状态机设计

* **字符驱动**：根据输入字符类型切换解析状态
* **状态标志**：使用 `in_number` 标记数字解析状态
* **符号处理**：支持负数的解析

#### 2. 栈的应用

* **层级管理**：使用栈处理嵌套结构
* **自动构建**：通过栈操作自动构建嵌套列表
* **错误恢复**：栈结构天然支持嵌套错误的检测

#### 3. Rust 特性利用

* **模式匹配**：使用 `match` 表达式处理字符类型
* **枚举类型**：优雅地表示嵌套数据类型
* **所有权管理**：安全的栈操作和内存管理

---

### 测试用例设计

#### 基础测试

```rust
#[test]
fn test_basic_cases() {
    // 纯数字测试
    assert_eq!(
        Solution::deserialize("324".to_string()),
        NestedInteger::Int(324)
    );
    
    // 简单嵌套测试
    assert_eq!(
        Solution::deserialize("[123]".to_string()),
        NestedInteger::List(vec![NestedInteger::Int(123)])
    );
}
```

#### 复杂嵌套测试

```rust
#[test]
fn test_complex_nesting() {
    // 多层嵌套测试
    assert_eq!(
        Solution::deserialize("[123,[456,[789]]]".to_string()),
        NestedInteger::List(vec![
            NestedInteger::Int(123),
            NestedInteger::List(vec![
                NestedInteger::Int(456),
                NestedInteger::List(vec![NestedInteger::Int(789)])
            ])
        ])
    );
    
    // 空列表测试
    assert_eq!(
        Solution::deserialize("[]".to_string()),
        NestedInteger::List(vec![])
    );
}
```

#### 边界条件测试

```rust
#[test]
fn test_edge_cases() {
    // 负数测试
    assert_eq!(
        Solution::deserialize("-123".to_string()),
        NestedInteger::Int(-123)
    );
    
    // 大数字测试
    assert_eq!(
        Solution::deserialize("1000000".to_string()),
        NestedInteger::Int(1000000)
    );
}
```

---

### 扩展思考

#### 1. 相关 LeetCode 问题

* **341. Flatten Nested List Iterator**：嵌套列表的迭代器实现
* **394. Decode String**：字符串解码，类似的栈应用
* **636. Exclusive Time of Functions**：函数调用栈的时间计算

#### 2. 实际应用场景

* **JSON 解析**：类似的嵌套数据结构解析
* **配置文件解析**：处理层次化的配置信息
* **表达式求值**：数学表达式的解析和计算

#### 3. 算法优化方向

* **错误处理**：添加更完善的错误检测和恢复机制
* **性能优化**：使用更高效的数据结构或算法
* **功能扩展**：支持更多数据类型和操作

---

### 总结

**核心技巧**：
1. **栈的应用**：使用栈处理嵌套结构的经典模式
2. **状态机设计**：基于字符类型的状态切换
3. **Rust 枚举**：优雅地表示复杂的数据类型

**实现细节**：
1. **快速路径优化**：纯数字输入的快速处理
2. **符号处理**：支持负数的正确解析
3. **嵌套管理**：通过栈操作维护层级关系

**学习价值**：
1. **解析器设计**：学习如何设计简单的解析器
2. **状态管理**：掌握复杂状态的处理方法
3. **Rust 特性**：深入理解枚举和模式匹配的应用